
/* This expects the following variables to be defined (besides
   the usual ones from pyconfig.h

   SIZEOF_LONG_DOUBLE -- sizeof(long double) or sizeof(double) if no
                         long double is present on platform.
   CHAR_BIT       --     number of bits in a char (usually 8)
                         (should be in limits.h)
*/

#ifndef Py_ARRAYOBJECT_H
#define Py_ARRAYOBJECT_H
#ifdef __cplusplus
#define CONFUSE_EMACS {
#define CONFUSE_EMACS2 }
extern "C" CONFUSE_EMACS
#undef CONFUSE_EMACS
#undef CONFUSE_EMACS2
/* ... otherwise a semi-smart idententer (like emacs) tries to indent
       everything when you're typing */
#endif
/* This is auto-generated by the installer */
#include "config.h"

/* There are several places in the code where an array of dimensions is */
/* allocated statically.  This is the size of that static allocation. */
/*  The array creation itself could have arbitrary dimensions but
 *  all the places where static allocation is used would need to
 *  be changed to dynamic (including inside of several structures)
 */

#define NPY_MAXDIMS 32

/* Used for Converter Functions "O&" code in ParseTuple */
#define NPY_FAIL 0
#define NPY_SUCCEED 1

        /* Helpful to distinguish what is installed */
#define NPY_VERSION 0x01000000

	/* Some platforms don't define bool, long long, or long double.
	   Handle that here.
	 */

#ifdef PY_LONG_LONG
typedef PY_LONG_LONG npy_longlong;
typedef unsigned PY_LONG_LONG npy_ulonglong;
#  ifdef _MSC_VER
#    define NPY_LONGLONG_FMT         "I64d"
#    define NPY_ULONGLONG_FMT        "I64u"
#    define NPY_LONGLONG_SUFFIX(x)   (x##i64)
#    define NPY_ULONGLONG_SUFFIX(x)  (x##Ui64)
#  else
	/* #define LONGLONG_FMT   "lld"      Another possible variant
           #define ULONGLONG_FMT  "llu"

	   #define LONGLONG_FMT   "qd"   -- BSD perhaps?
	   #define ULONGLONG_FMT   "qu"
	*/
#    define NPY_LONGLONG_FMT         "Ld"
#    define NPY_ULONGLONG_FMT        "Lu"
#    define NPY_LONGLONG_SUFFIX(x)   (x##LL)
#    define NPY_ULONGLONG_SUFFIX(x)  (x##ULL)
#  endif
#else
typedef long npy_longlong;
typedef unsigned long npy_ulonglong;
#  define NPY_LONGLONG_SUFFIX(x)  (x##L)
#  define NPY_ULONGLONG_SUFFIX(x) (x##UL)
#endif


typedef unsigned char npy_bool;
#define NPY_FALSE 0
#define NPY_TRUE 1

#if SIZEOF_LONG_DOUBLE==SIZEOF_DOUBLE
	typedef double npy_longdouble;
        #define NPY_LONGDOUBLE_FMT "g"
#else
	typedef long double npy_longdouble;
        #define NPY_LONGDOUBLE_FMT "Lg"
#endif

#ifndef Py_USING_UNICODE
#error Must use Python with unicode enabled. 
#endif


typedef signed char npy_byte;
typedef unsigned char npy_ubyte;
typedef unsigned short npy_ushort;
typedef unsigned int npy_uint;
typedef unsigned long npy_ulong;

/* These are for completeness */
typedef float npy_float;
typedef double npy_double;
typedef short npy_short;
typedef int npy_int;
typedef long npy_long;

typedef struct { float real, imag; } npy_cfloat;
typedef struct { double real, imag; } npy_cdouble;
typedef struct {npy_longdouble real, imag;} npy_clongdouble;

enum NPY_TYPES {    NPY_BOOL=0,
                    NPY_BYTE, NPY_UBYTE,
                    NPY_SHORT, NPY_USHORT,
                    NPY_INT, NPY_UINT,
                    NPY_LONG, NPY_ULONG,
                    NPY_LONGLONG, NPY_ULONGLONG,
                    NPY_FLOAT, NPY_DOUBLE, NPY_LONGDOUBLE,
                    NPY_CFLOAT, NPY_CDOUBLE, NPY_CLONGDOUBLE,
                    NPY_OBJECT=17,
                    NPY_STRING, NPY_UNICODE,
                    NPY_VOID,
                    NPY_NTYPES,
                    NPY_NOTYPE,
                    NPY_CHAR,      /* special flag */
                    NPY_USERDEF=256  /* leave room for characters */
};

/* basetype array priority */
#define NPY_PRIORITY 0.0

/* default subtype priority */
#define NPY_SUBTYPE_PRIORITY 1.0

/* default scalar priority */
#define NPY_SCALAR_PRIORITY -1000000.0

/* How many floating point types are there */
#define NPY_NUM_FLOATTYPE 3

/* We need to match npy_intp to a signed integer of the same size as
   a pointer variable. npy_uintp to the equivalent unsigned integer
*/


/* These characters correspond to the array type and the
   struct module */

/*  except 'p' -- signed integer for pointer type */

enum NPY_TYPECHAR { NPY_BOOLLTR = '?',
			NPY_BYTELTR = 'b',
			NPY_UBYTELTR = 'B',
			NPY_SHORTLTR = 'h',
			NPY_USHORTLTR = 'H',
			NPY_INTLTR = 'i',
			NPY_UINTLTR = 'I',
			NPY_LONGLTR = 'l',
			NPY_ULONGLTR = 'L',
			NPY_LONGLONGLTR = 'q',
			NPY_ULONGLONGLTR = 'Q',
			NPY_FLOATLTR = 'f',
			NPY_DOUBLELTR = 'd',
			NPY_LONGDOUBLELTR = 'g',
			NPY_CFLOATLTR = 'F',
			NPY_CDOUBLELTR = 'D',
			NPY_CLONGDOUBLELTR = 'G',
			NPY_OBJECTLTR = 'O',
			NPY_STRINGLTR = 'S',
			NPY_STRINGLTR2 = 'a',
			NPY_UNICODELTR = 'U',
		        NPY_VOIDLTR = 'V',
			NPY_CHARLTR = 'c',

			/* No Descriptor, just a define -- this let's
			 Python users specify an array of integers
			 large enough to hold a pointer on the platform*/
			NPY_INTPLTR = 'p',
			NPY_UINTPLTR = 'P',

			NPY_GENBOOLLTR ='b',
			NPY_SIGNEDLTR = 'i',
			NPY_UNSIGNEDLTR = 'u',
			NPY_FLOATINGLTR = 'f',
			NPY_COMPLEXLTR = 'c'
};

typedef enum {
	NPY_QUICKSORT=0,
	NPY_HEAPSORT=1,
	NPY_MERGESORT=2,
} NPY_SORTKIND;
#define NPY_NSORTS NPY_MERGESORT + 1


typedef enum {
	NPY_NOSCALAR=-1,
	NPY_BOOL_SCALAR,
	NPY_INTPOS_SCALAR,
	NPY_INTNEG_SCALAR,
	NPY_FLOAT_SCALAR,
	NPY_COMPLEX_SCALAR,
	NPY_OBJECT_SCALAR,
} NPY_SCALARKIND;
#define NPY_NSCALARKINDS NPY_OBJECT_SCALAR+1

typedef enum {
        NPY_ANYORDER=-1,
        NPY_CORDER=0,
        NPY_FORTRANORDER=1
} NPY_ORDER;


	/* Define bit-width array types and typedefs */

#define NPY_MAX_INT8 127
#define NPY_MIN_INT8 -128
#define NPY_MAX_UINT8 255
#define NPY_MAX_INT16 32767
#define NPY_MIN_INT16 -32768
#define NPY_MAX_UINT16 65535
#define NPY_MAX_INT32 2147483647
#define NPY_MIN_INT32 (-NPY_MAX_INT32 - 1)
#define NPY_MAX_UINT32 4294967295U
#define NPY_MAX_INT64 NPY_LONGLONG_SUFFIX(9223372036854775807)
#define NPY_MIN_INT64 (-NPY_MAX_INT64 - NPY_LONGLONG_SUFFIX(1))
#define NPY_MAX_UINT64 NPY_ULONGLONG_SUFFIX(18446744073709551615)
#define NPY_MAX_INT128 NPY_LONGLONG_SUFFIX(85070591730234615865843651857942052864)
#define NPY_MIN_INT128 (-NPY_MAX_INT128 - NPY_LONGLONG_SUFFIX(1))
#define NPY_MAX_UINT128 NPY_ULONGLONG_SUFFIX(170141183460469231731687303715884105728)
#define NPY_MAX_INT256 NPY_LONGLONG_SUFFIX(57896044618658097711785492504343953926634992332820282019728792003956564819967)
#define NPY_MIN_INT256 (-NPY_MAX_INT256 - NPY_LONGLONG_SUFFIX(1))
#define NPY_MAX_UINT256 NPY_ULONGLONG_SUFFIX(115792089237316195423570985008687907853269984665640564039457584007913129639935)

	/* Need to find the number of bits for each type and
	   make definitions accordingly.

	   C states that sizeof(char) == 1 by definition

	   So, just using the sizeof keyword won't help.

	   It also looks like Python itself uses sizeof(char) quite a
	   bit, which by definition should be 1 all the time.

	   Idea: Make Use of CHAR_BIT which should tell us how many
	   BITS per CHARACTER
	*/

	/* Include platform definitions -- These are in the C89/90 standard */
#include <limits.h>
#define NPY_MAX_BYTE SCHAR_MAX
#define NPY_MIN_BYTE SCHAR_MIN
#define NPY_MAX_UBYTE UCHAR_MAX
#define NPY_MAX_SHORT SHRT_MAX
#define NPY_MIN_SHORT SHRT_MIN
#define NPY_MAX_USHORT USHRT_MAX
#define NPY_MAX_INT   INT_MAX
#ifndef INT_MIN
#define INT_MIN (-INT_MAX - 1)
#endif
#define NPY_MIN_INT   INT_MIN
#define NPY_MAX_UINT  UINT_MAX
#define NPY_MAX_LONG  LONG_MAX
#define NPY_MIN_LONG  LONG_MIN
#define NPY_MAX_ULONG  ULONG_MAX


#define NPY_SIZEOF_LONG SIZEOF_LONG
#define NPY_SIZEOF_INT SIZEOF_INT
#define NPY_SIZEOF_SHORT SIZEOF_SHORT
#define NPY_SIZEOF_FLOAT SIZEOF_FLOAT
#define NPY_SIZEOF_DOUBLE SIZEOF_DOUBLE
#define NPY_SIZEOF_LONGDOUBLE SIZEOF_LONG_DOUBLE
#define NPY_SIZEOF_LONGLONG SIZEOF_LONG_LONG
#define NPY_BITSOF_BOOL sizeof(npy_bool)*CHAR_BIT
#define NPY_BITSOF_CHAR CHAR_BIT
#define NPY_BITSOF_SHORT (SIZEOF_SHORT*CHAR_BIT)
#define NPY_BITSOF_INT (SIZEOF_INT*CHAR_BIT)
#define NPY_BITSOF_LONG (SIZEOF_LONG*CHAR_BIT)
#define NPY_BITSOF_LONGLONG (NPY_SIZEOF_LONGLONG*CHAR_BIT)
#define NPY_BITSOF_FLOAT (SIZEOF_FLOAT*CHAR_BIT)
#define NPY_BITSOF_DOUBLE (SIZEOF_DOUBLE*CHAR_BIT)
#define NPY_BITSOF_LONGDOUBLE (NPY_SIZEOF_LONGDOUBLE*CHAR_BIT)

#if NPY_BITSOF_LONG == 8
#define NPY_INT8 NPY_LONG
#define NPY_UINT8 NPY_ULONG
	typedef long npy_int8;
	typedef unsigned long npy_uint8;
#elif NPY_BITSOF_LONG == 16
#define NPY_INT16 NPY_LONG
#define NPY_UINT16 NPY_ULONG
	typedef long npy_int16;
	typedef unsigned long npy_uint16;
#elif NPY_BITSOF_LONG == 32
#define NPY_INT32 NPY_LONG
#define NPY_UINT32 NPY_ULONG
	typedef long npy_int32;
	typedef unsigned long npy_uint32;
	typedef unsigned long npy_ucs4;
#elif NPY_BITSOF_LONG == 64
#define NPY_INT64 NPY_LONG
#define NPY_UINT64 NPY_ULONG
	typedef long npy_int64;
	typedef unsigned long npy_uint64;
#elif NPY_BITSOF_LONG == 128
#define NPY_INT128 NPY_LONG
#define NPY_UINT128 NPY_ULONG
	typedef long npy_int128;
	typedef unsigned long npy_uint128;
#endif

#if NPY_BITSOF_LONGLONG == 8
#  ifndef NPY_INT8
#    define NPY_INT8 NPY_LONGLONG
#    define NPY_UINT8 NPY_ULONGLONG
	typedef npy_longlong npy_int8;
	typedef npy_ulonglong npy_uint8;
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT8
#  define NPY_MIN_LONGLONG NPY_MIN_INT8
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT8
#elif NPY_BITSOF_LONGLONG == 16
#  ifndef NPY_INT16
#    define NPY_INT16 NPY_LONGLONG
#    define NPY_UINT16 NPY_ULONGLONG
	typedef npy_longlong npy_int16;
	typedef npy_ulonglong npy_uint16;
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT16
#  define NPY_MIN_LONGLONG NPY_MIN_INT16
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT16
#elif NPY_BITSOF_LONGLONG == 32
#  ifndef NPY_INT32
#    define NPY_INT32 NPY_LONGLONG
#    define NPY_UINT32 NPY_ULONGLONG
	typedef npy_longlong npy_int32;
	typedef npy_ulonglong npy_uint32;
	typedef npy_ulonglong npy_ucs4;
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT32
#  define NPY_MIN_LONGLONG NPY_MIN_INT32
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT32
#elif NPY_BITSOF_LONGLONG == 64
#  ifndef NPY_INT64
#    define NPY_INT64 NPY_LONGLONG
#    define NPY_UINT64 NPY_ULONGLONG
	typedef npy_longlong npy_int64;
	typedef npy_ulonglong npy_uint64;
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT64
#  define NPY_MIN_LONGLONG NPY_MIN_INT64
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT64
#elif NPY_BITSOF_LONGLONG == 128
#  ifndef NPY_INT128
#    define NPY_INT128 NPY_LONGLONG
#    define NPY_UINT128 NPY_ULONGLONG
	typedef npy_longlong npy_int128;
	typedef npy_ulonglong npy_uint128;
#  endif
#  define NPY_MAX_LONGLONG NPY_MAX_INT128
#  define NPY_MIN_LONGLONG NPY_MIN_INT128
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT128
#elif NPY_BITSOF_LONGLONG == 256
#  define NPY_INT256 NPY_LONGLONG
#  define NPY_UINT256 NPY_ULONGLONG
	typedef npy_longlong npy_int256;
	typedef npy_ulonglong npy_uint256;
#  define NPY_MAX_LONGLONG NPY_MAX_INT256
#  define NPY_MIN_LONGLONG NPY_MIN_INT256
#  define NPY_MAX_ULONGLONG NPY_MAX_UINT256
#endif

#if NPY_BITSOF_INT == 8
#ifndef NPY_INT8
#define NPY_INT8 NPY_INT
#define NPY_UINT8 NPY_UINT
	typedef int npy_int8;
	typedef unsigned int npy_uint8;
#endif
#elif NPY_BITSOF_INT == 16
#ifndef NPY_INT16
#define NPY_INT16 NPY_INT
#define NPY_UINT16 NPY_UINT
	typedef int npy_int16;
	typedef unsigned int npy_uint16;
#endif
#elif NPY_BITSOF_INT == 32
#ifndef NPY_INT32
#define NPY_INT32 NPY_INT
#define NPY_UINT32 NPY_UINT
	typedef int npy_int32;
	typedef unsigned int npy_uint32;
        typedef unsigned int npy_ucs4;
#endif
#elif NPY_BITSOF_INT == 64
#ifndef NPY_INT64
#define NPY_INT64 NPY_INT
#define NPY_UINT64 NPY_UINT
	typedef int npy_int64;
	typedef unsigned int npy_uint64;
#endif
#elif NPY_BITSOF_INT == 128
#ifndef NPY_INT128
#define NPY_INT128 NPY_INT
#define NPY_UINT128 NPY_UINT
	typedef int npy_int128;
	typedef unsigned int npy_uint128;
#endif
#endif

#if NPY_BITSOF_SHORT == 8
#ifndef NPY_INT8
#define NPY_INT8 NPY_SHORT
#define NPY_UINT8 NPY_USHORT
	typedef short npy_int8;
	typedef unsigned short npy_uint8;
#endif
#elif NPY_BITSOF_SHORT == 16
#ifndef NPY_INT16
#define NPY_INT16 NPY_SHORT
#define NPY_UINT16 NPY_USHORT
	typedef short npy_int16;
	typedef unsigned short npy_uint16;
#endif
#elif NPY_BITSOF_SHORT == 32
#ifndef NPY_INT32
#define NPY_INT32 NPY_SHORT
#define NPY_UINT32 NPY_USHORT
	typedef short npy_int32;
	typedef unsigned short npy_uint32;
	typedef unsigned short npy_ucs4;
#endif
#elif NPY_BITSOF_SHORT == 64
#ifndef NPY_INT64
#define NPY_INT64 NPY_SHORT
#define NPY_UINT64 NPY_USHORT
	typedef short npy_int64;
	typedef unsigned short npy_uint64;
#endif
#elif NPY_BITSOF_SHORT == 128
#ifndef NPY_INT128
#define NPY_INT128 NPY_SHORT
#define NPY_UINT128 NPY_USHORT
	typedef short npy_int128;
	typedef unsigned short npy_uint128;
#endif
#endif


#if NPY_BITSOF_CHAR == 8
#ifndef NPY_INT8
#define NPY_INT8 NPY_BYTE
#define NPY_UINT8 NPY_UBYTE
	typedef signed char npy_int8;
	typedef unsigned char npy_uint8;
#endif
#elif NPY_BITSOF_CHAR == 16
#ifndef NPY_INT16
#define NPY_INT16 NPY_BYTE
#define NPY_UINT16 NPY_UBYTE
	typedef signed char npy_int16;
	typedef unsigned char npy_uint16;
#endif
#elif NPY_BITSOF_CHAR == 32
#ifndef NPY_INT32
#define NPY_INT32 NPY_BYTE
#define NPY_UINT32 NPY_UBYTE
	typedef signed char npy_int32;
	typedef unsigned char npy_uint32;
	typedef unsigned char npy_ucs4;
#endif
#elif NPY_BITSOF_CHAR == 64
#ifndef NPY_INT64
#define NPY_INT64 NPY_BYTE
#define NPY_UINT64 NPY_UBYTE
	typedef signed char npy_int64;
	typedef unsigned char npy_uint64;
#endif
#elif NPY_BITSOF_CHAR == 128
#ifndef NPY_INT128
#define NPY_INT128 NPY_BYTE
#define NPY_UINT128 NPY_UBYTE
	typedef signed char npy_int128;
	typedef unsigned char npy_uint128;
#endif
#endif



#if NPY_BITSOF_DOUBLE == 16
#ifndef NPY_FLOAT16
#define NPY_FLOAT16 NPY_DOUBLE
#define NPY_COMPLEX32 NPY_CDOUBLE
	typedef  double npy_float16;
	typedef npy_cdouble npy_complex32;
#endif
#elif NPY_BITSOF_DOUBLE == 32
#ifndef NPY_FLOAT32
#define NPY_FLOAT32 NPY_DOUBLE
#define NPY_COMPLEX64 NPY_CDOUBLE
	typedef double npy_float32;
	typedef npy_cdouble npy_complex64;
#endif
#elif NPY_BITSOF_DOUBLE == 64
#ifndef NPY_FLOAT64
#define NPY_FLOAT64 NPY_DOUBLE
#define NPY_COMPLEX128 NPY_CDOUBLE
	typedef double npy_float64;
	typedef npy_cdouble npy_complex128;
#endif
#elif NPY_BITSOF_DOUBLE == 80
#ifndef NPY_FLOAT80
#define NPY_FLOAT80 NPY_DOUBLE
#define NPY_COMPLEX160 NPY_CDOUBLE
	typedef double npy_float80;
	typedef npy_cdouble npy_complex160;
#endif
#elif NPY_BITSOF_DOUBLE == 96
#ifndef NPY_FLOAT96
#define NPY_FLOAT96 NPY_DOUBLE
#define NPY_COMPLEX192 NPY_CDOUBLE
	typedef double npy_float96;
	typedef npy_cdouble npy_complex192;
#endif
#elif NPY_BITSOF_DOUBLE == 128
#ifndef NPY_FLOAT128
#define NPY_FLOAT128 NPY_DOUBLE
#define NPY_COMPLEX256 NPY_CDOUBLE
	typedef double npy_float128;
	typedef npy_cdouble npy_complex256;
#endif
#endif



#if NPY_BITSOF_FLOAT == 16
#ifndef NPY_FLOAT16
#define NPY_FLOAT16 NPY_FLOAT
#define NPY_COMPLEX32 NPY_CFLOAT
	typedef float npy_float16;
	typedef npy_cfloat npy_complex32;
#endif
#elif NPY_BITSOF_FLOAT == 32
#ifndef NPY_FLOAT32
#define NPY_FLOAT32 NPY_FLOAT
#define NPY_COMPLEX64 NPY_CFLOAT
	typedef float npy_float32;
	typedef npy_cfloat npy_complex64;
#endif
#elif NPY_BITSOF_FLOAT == 64
#ifndef NPY_FLOAT64
#define NPY_FLOAT64 NPY_FLOAT
#define NPY_COMPLEX128 NPY_CFLOAT
	typedef float npy_float64;
	typedef npy_cfloat npy_complex128;
#endif
#elif NPY_BITSOF_FLOAT == 80
#ifndef NPY_FLOAT80
#define NPY_FLOAT80 NPY_FLOAT
#define NPY_COMPLEX160 NPY_CFLOAT
	typedef float npy_float80;
	typedef npy_cfloat npy_complex160;
#endif
#elif NPY_BITSOF_FLOAT == 96
#ifndef NPY_FLOAT96
#define NPY_FLOAT96 NPY_FLOAT
#define NPY_COMPLEX192 NPY_CFLOAT
	typedef float npy_float96;
	typedef npy_cfloat npy_complex192;
#endif
#elif NPY_BITSOF_FLOAT == 128
#ifndef NPY_FLOAT128
#define NPY_FLOAT128 NPY_FLOAT
#define NPY_COMPLEX256 NPY_CFLOAT
	typedef float npy_float128;
	typedef npy_cfloat npy_complex256;
#endif
#endif


#if NPY_BITSOF_LONGDOUBLE == 16
#ifndef NPY_FLOAT16
#define NPY_FLOAT16 NPY_LONGDOUBLE
#define NPY_COMPLEX32 NPY_CLONGDOUBLE
	typedef npy_longdouble npy_float16;
	typedef npy_clongdouble npy_complex32;
#endif
#elif NPY_BITSOF_LONGDOUBLE == 32
#ifndef NPY_FLOAT32
#define NPY_FLOAT32 NPY_LONGDOUBLE
#define NPY_COMPLEX64 NPY_CLONGDOUBLE
	typedef npy_longdouble npy_float32;
	typedef npy_clongdouble npy_complex64;
#endif
#elif NPY_BITSOF_LONGDOUBLE == 64
#ifndef NPY_FLOAT64
#define NPY_FLOAT64 NPY_LONGDOUBLE
#define NPY_COMPLEX128 NPY_CLONGDOUBLE
	typedef npy_longdouble npy_float64;
	typedef npy_clongdouble npy_complex128;
#endif
#elif NPY_BITSOF_LONGDOUBLE == 80
#ifndef NPY_FLOAT80
#define NPY_FLOAT80 NPY_LONGDOUBLE
#define NPY_COMPLEX160 NPY_CLONGDOUBLE
	typedef npy_longdouble npy_float80;
	typedef npy_clongdouble npy_complex160;
#endif
#elif NPY_BITSOF_LONGDOUBLE == 96
#ifndef NPY_FLOAT96
#define NPY_FLOAT96 NPY_LONGDOUBLE
#define NPY_COMPLEX192 NPY_CLONGDOUBLE
	typedef npy_longdouble npy_float96;
	typedef npy_clongdouble npy_complex192;
#endif
#elif NPY_BITSOF_LONGDOUBLE == 128
#ifndef NPY_FLOAT128
#define NPY_FLOAT128 NPY_LONGDOUBLE
#define NPY_COMPLEX256 NPY_CLONGDOUBLE
	typedef npy_longdouble npy_float128;
	typedef npy_clongdouble npy_complex256;
#endif
#elif NPY_BITSOF_LONGDOUBLE == 256
#define NPY_FLOAT256 NPY_LONGDOUBLE
#define NPY_COMPLEX512 NPY_CLONGDOUBLE
	typedef npy_longdouble npy_float256;
	typedef npy_clongdouble npy_complex512;
#endif

	/* End of typedefs for numarray style bit-width names */

/* This is to typedef npy_intp to the appropriate pointer size for this platform.
 * Py_intptr_t, Py_uintptr_t are defined in pyport.h. */
typedef Py_intptr_t npy_intp;
typedef Py_uintptr_t npy_uintp;
#define NPY_SIZEOF_INTP SIZEOF_PY_INTPTR_T
#define NPY_SIZEOF_UINTP SIZEOF_PY_INTPTR_T

#if (PY_VERSION_HEX < 0x02050000)
typedef int Py_ssize_t
#define PY_SSIZE_T_MAX INT_MAX
#define PY_SSIZE_T_MIN INT_MIN
#define NPY_SSIZE_T_PYFMT "i"
#else
#define NPY_SSIZE_T_PYFMT "n"
#endif

#if SIZEOF_PY_INTPTR_T == SIZEOF_INT
	#define NPY_INTP NPY_INT
	#define NPY_UINTP NPY_UINT
        #define PyIntpArrType_Type PyIntArrType_Type
        #define PyUIntpArrType_Type PyUIntArrType_Type
	#define NPY_MAX_INTP NPY_MAX_INT
	#define NPY_MIN_INTP NPY_MIN_INT
	#define NPY_MAX_UINTP NPY_MAX_UINT
        #define NPY_INTP_FMT "d"
#elif SIZEOF_PY_INTPTR_T == SIZEOF_LONG
	#define NPY_INTP NPY_LONG
	#define NPY_UINTP NPY_ULONG
        #define PyIntpArrType_Type PyLongArrType_Type
        #define PyUIntpArrType_Type PyULongArrType_Type
	#define NPY_MAX_INTP NPY_MAX_LONG
	#define NPY_MIN_INTP MIN_LONG
	#define NPY_MAX_UINTP NPY_MAX_ULONG
        #define NPY_INTP_FMT "ld"
#elif defined(PY_LONG_LONG) && (SIZEOF_PY_INTPTR_T == SIZEOF_LONG_LONG)
	#define NPY_INTP NPY_LONGLONG
	#define NPY_UINTP NPY_ULONGLONG
        #define PyIntpArrType_Type PyLongLongArrType_Type
        #define PyUIntpArrType_Type PyULongLongArrType_Type
	#define NPY_MAX_INTP NPY_MAX_LONGLONG
	#define NPY_MIN_INTP NPY_MIN_LONGLONG
	#define NPY_MAX_UINTP NPY_MAX_ULONGLONG
        #define NPY_INTP_FMT "Ld"
#endif

#define NPY_ERR(str) fprintf(stderr, #str); fflush(stderr);
#define NPY_ERR2(str) fprintf(stderr, str); fflush(stderr);

#define NPY_STRINGIFY(x) #x
#define NPY_TOSTRING(x) NPY_STRINGIFY(x)

  /* Macros to define how array, and dimension/strides data is
     allocated.
  */

  /* Data buffer */
#define PyDataMem_NEW(size) ((char *)malloc(size))
  /* #define PyArrayMem_NEW(size) PyMem_NEW(char, size)*/
#define PyDataMem_FREE(ptr)  free(ptr)
  /* #define PyArrayMem_FREE(ptr) PyMem_Free(ptr) */
#define PyDataMem_RENEW(ptr,size) ((char *)realloc(ptr,size))

#define NPY_USE_PYMEM 0

#if NPY_USE_PYMEM == 1
#define PyArray_malloc PyObject_Malloc
#define PyArray_free PyObject_Free
#define PyArray_realloc PyObject_Realloc
#else
#define PyArray_malloc malloc
#define PyArray_free free
#define PyArray_realloc realloc
#endif

/* Dimensions and strides */
#define PyDimMem_NEW(size) ((npy_intp *)PyArray_malloc(size*sizeof(npy_intp)))
#define PyDimMem_FREE(ptr) PyArray_free(ptr)
#define PyDimMem_RENEW(ptr,size) ((npy_intp *)PyArray_realloc(ptr,size*sizeof(npy_intp)))


  /* These must deal with unaligned and swapped data if necessary */
typedef PyObject * (PyArray_GetItemFunc) (void *, void *);
typedef int (PyArray_SetItemFunc)(PyObject *, void *, void *);

typedef void (PyArray_CopySwapNFunc)(void *, npy_intp, void *, npy_intp, npy_intp, int, void *);
typedef void (PyArray_CopySwapFunc)(void *, void *, int, void *);
typedef npy_bool (PyArray_NonzeroFunc)(void *, void *);


  /* These assume aligned and notswapped data -- a buffer will be
      used before or contiguous data will be obtained
  */
typedef int (PyArray_CompareFunc)(const void *, const void *, void *);
typedef int (PyArray_ArgFunc)(void*, npy_intp, npy_intp*, void *);
typedef void (PyArray_DotFunc)(void *, npy_intp, void *, npy_intp, void *, npy_intp,
			       void *);
typedef void (PyArray_VectorUnaryFunc)(void *, void *, npy_intp, void *, void *);
typedef int (PyArray_ScanFunc)(FILE *, void *, void *, void *);
typedef int (PyArray_FromStrFunc)(char *, void *, char **, void *);

typedef int (PyArray_FillFunc)(void *, npy_intp, void *);

typedef int (PyArray_SortFunc)(void *, npy_intp, void *);
typedef int (PyArray_ArgSortFunc)(void *, npy_intp *, npy_intp, void *);

typedef int (PyArray_FillWithScalarFunc)(void *, npy_intp, void *, void *);

typedef int (PyArray_ScalarKindFunc)(void *);

typedef struct {
        npy_intp *ptr;
        int len;
} PyArray_Dims;

typedef struct {
	/* Functions to cast to all other standard types*/
	/* Can have some NULL entries */
	PyArray_VectorUnaryFunc *cast[NPY_NTYPES];

	/* The next four functions *cannot* be NULL */

	/* Functions to get and set items with standard
	   Python types -- not array scalars */
	PyArray_GetItemFunc *getitem;
	PyArray_SetItemFunc *setitem;

	/* Copy and/or swap data.  Memory areas may not overlap */
	/*  Use memmove first if they might */
	PyArray_CopySwapNFunc *copyswapn;
        PyArray_CopySwapFunc *copyswap;

	/* Function to compare items */
	/* Can be NULL 
	 */
	PyArray_CompareFunc *compare;

	/* Function to select largest 
	   Can be NULL
	*/
	PyArray_ArgFunc *argmax;

	/* Function to compute dot product */
	/* Can be NULL */
	PyArray_DotFunc	*dotfunc;

	/* Function to scan an ASCII file and
	   place a single value plus possible separator 
	   Can be NULL 
	*/
	PyArray_ScanFunc *scanfunc;

	/* Function to read a single value from a string */
	/* and adjust the pointer; Can be NULL */
	PyArray_FromStrFunc *fromstr;

	/* Function to determine if data is zero or not */
	/* If NULL a default version is */
	/* used at Registration time. */
	PyArray_NonzeroFunc *nonzero;

	/* Used for arange. Can be NULL.*/
	PyArray_FillFunc *fill;

	/* Function to fill arrays with scalar values 
	 Can be NULL*/
	PyArray_FillWithScalarFunc *fillwithscalar;

	/* Sorting functions; Can be NULL*/
	PyArray_SortFunc *sort[NPY_NSORTS];
	PyArray_ArgSortFunc *argsort[NPY_NSORTS];

	/* Dictionary of additional casting functions
	   PyArray_VectorUnaryFuncs
	   which can be populated to support casting
	   to other registered types. Can be NULL*/
	PyObject *castdict;

	/* Functions useful for generalizing
	   the casting rules.  Can be NULL;
	*/
	PyArray_ScalarKindFunc *scalarkind;
	int **cancastscalarkindto;
	int *cancastto;

	/* Set to 1 if you want pickles of this type
	   to go out as lists of _getitem objects
	*/
	int listpickle;

} PyArray_ArrFuncs;


typedef struct {
	PyObject_HEAD
	PyTypeObject *typeobj;  /* the type object representing an
				   instance of this type -- should not
				   be two type_numbers with the same type
				   object. */
	char kind;              /* kind for this type */
	char type;              /* unique-character representing this type */
	char byteorder;         /* '>' (big), '<' (little), '|'
				   (not-applicable), or '=' (native). */
        char hasobject;        /* non-zero if it has object arrays in fields */
	int type_num;          /* number representing this type */
	int elsize;             /* element size for this type */
	int alignment;          /* alignment needed for this type */
	struct _arr_descr					\
	*subarray;              /* Non-NULL if this type is
				   is an array (C-contiguous)
				   of some other type
				*/
	PyObject *fields;       /* The fields dictionary for this type */
	                        /* For statically defined descr this
				   is always Py_None */

        PyObject *names;        /* An ordered tuple of field names or NULL
                                   if no fields are defined */

	PyArray_ArrFuncs *f;     /* a table of functions specific for each
				    basic data descriptor */
} PyArray_Descr;

typedef struct _arr_descr {
	PyArray_Descr *base;
	PyObject *shape;       /* a tuple */
} PyArray_ArrayDescr;

/*
  The main array object structure. It is recommended to use the macros
  defined below (PyArray_DATA and friends) access fields here, instead
  of the members themselves.
 */

typedef struct PyArrayObject {
	PyObject_HEAD
	char *data;             /* pointer to raw data buffer */
	int nd;                 /* number of dimensions, also called ndim */
	npy_intp *dimensions;       /* size in each dimension */
        npy_intp *strides;          /* bytes to jump to get to the
				   next element in each dimension */
	PyObject *base;         /* This object should be decref'd
				   upon deletion of array */
	                        /* For views it points to the original array */
	                        /* For creation from buffer object it points
				   to an object that shold be decref'd on
				   deletion */
	                        /* For UPDATEIFCOPY flag this is an array
				   to-be-updated upon deletion of this one */
	PyArray_Descr *descr;   /* Pointer to type structure */
	int flags;              /* Flags describing array -- see below*/
	PyObject *weakreflist;  /* For weakreferences */
} PyArrayObject;

#define NPY_AO PyArrayObject

#define fortran fortran_        /* For some compilers */

/* Mirrors buffer object to ptr */

typedef struct {
        PyObject_HEAD
        PyObject *base;
        void *ptr;
        npy_intp len;
        int flags;
} PyArray_Chunk;

typedef int (PyArray_FinalizeFunc)(PyArrayObject *, PyObject *);

/* Means c-style contiguous (last index varies the fastest). The
   data elements right after each other. */
#define NPY_CONTIGUOUS    0x0001
/* set if array is a contiguous Fortran array: the first index
   varies the fastest in memory (strides array is reverse of
   C-contiguous array)*/
#define NPY_FORTRAN       0x0002

/*
  Note: all 0-d arrays are CONTIGUOUS and FORTRAN contiguous. If a
   1-d array is CONTIGUOUS it is also FORTRAN contiguous
*/

/* If set, the array owns the data: it will be free'd when the array
   is deleted. */
#define NPY_OWNDATA       0x0004

/* An array never has the next four set; they're only used as parameter
   flags to the the various FromAny functions */

/* Cause a cast to occur regardless of whether or not it is safe. */
#define NPY_FORCECAST     0x0010

/* Always copy the array. Returned arrays are always CONTIGUOUS, ALIGNED,
   and WRITEABLE. */
#define NPY_ENSURECOPY    0x0020

/* Make sure the returned array is an ndarray or a bigndarray */
#define NPY_ENSUREARRAY   0x0040

/* Make sure that the strides are in units of the element size
   Needed for some operations with record-arrays.
*/
#define NPY_ELEMENTSTRIDES 0x0080

/* Array data is aligned on the appropiate memory address for the
   type stored according to how the compiler would align things
   (e.g., an array of integers (4 bytes each) starts on
   a memory address that's a multiple of 4) */
#define NPY_ALIGNED       0x0100
/* Array data has the native endianness */
#define NPY_NOTSWAPPED    0x0200
/* Array data is writeable */
#define NPY_WRITEABLE     0x0400
/* If this flag is set, then base contains a pointer to an array of
   the same size that should be updated with the current contents of
   this array when this array is deallocated
*/
#define NPY_UPDATEIFCOPY  0x1000

/* This flag is for the array interface */
#define NPY_ARR_HAS_DESCR  0x0800


#define NPY_BEHAVED NPY_ALIGNED | NPY_WRITEABLE
#define NPY_BEHAVED_NS NPY_ALIGNED | NPY_WRITEABLE | NPY_NOTSWAPPED
#define NPY_CARRAY NPY_CONTIGUOUS | NPY_BEHAVED
#define NPY_CARRAY_RO NPY_CONTIGUOUS | NPY_ALIGNED
#define NPY_FARRAY NPY_FORTRAN | NPY_BEHAVED
#define NPY_FARRAY_RO NPY_FORTRAN | NPY_ALIGNED
#define NPY_DEFAULT NPY_CARRAY
#define NPY_IN_ARRAY NPY_CARRAY_RO
#define NPY_OUT_ARRAY NPY_CARRAY 
#define NPY_INOUT_ARRAY NPY_CARRAY | NPY_UPDATEIFCOPY
#define NPY_IN_FARRAY NPY_FARRAY_RO
#define NPY_OUT_FARRAY NPY_FARRAY
#define NPY_INOUT_FARRAY NPY_FARRAY | NPY_UPDATEIFCOPY

#define NPY_UPDATE_ALL NPY_CONTIGUOUS | NPY_FORTRAN | NPY_ALIGNED


/* Size of internal buffers used for alignment */
/* Make BUFSIZE a multiple of sizeof(cdouble) -- ususally 16 */
/* So that ufunc buffers are aligned */
#define NPY_MIN_BUFSIZE sizeof(cdouble)
#define NPY_MAX_BUFSIZE sizeof(cdouble)*1000000
#define NPY_BUFSIZE 10000 
/* #define NPY_BUFSIZE 80*/

#define PyArray_MAX(a,b) (((a)>(b))?(a):(b))
#define PyArray_MIN(a,b) (((a)<(b))?(a):(b))


/*
 * C API:  consists of Macros and functions.  The MACROS are defined here.
 */


#define PyArray_CHKFLAGS(m, FLAGS) \
	((((PyArrayObject *)(m))->flags & (FLAGS)) == (FLAGS))
#define PyArray_ISCONTIGUOUS(m) PyArray_CHKFLAGS(m, NPY_CONTIGUOUS)
#define PyArray_ISWRITEABLE(m) PyArray_CHKFLAGS(m, NPY_WRITEABLE)
#define PyArray_ISALIGNED(m) PyArray_CHKFLAGS(m, NPY_ALIGNED)


#if NPY_ALLOW_THREADS
#define NPY_BEGIN_ALLOW_THREADS Py_BEGIN_ALLOW_THREADS
#define NPY_END_ALLOW_THREADS Py_END_ALLOW_THREADS
#define NPY_BEGIN_THREADS_DEF PyThreadState *_save=NULL;
#define NPY_BEGIN_THREADS _save = PyEval_SaveThread();
#define NPY_END_THREADS   if (_save) PyEval_RestoreThread(_save);
#define NPY_BEGIN_THREADS_DESCR(dtype) if (!((dtype)->hasobject)) NPY_BEGIN_THREADS
#define NPY_END_THREADS_DESCR(dtype) if (!((dtype)->hasobject)) NPY_END_THREADS
#define NPY_ALLOW_C_API_DEF  PyGILState_STATE __save__;
#define NPY_ALLOW_C_API      __save__ = PyGILState_Ensure();
#define NPY_DISABLE_C_API    PyGILState_Release(__save__);
#else
#define NPY_BEGIN_ALLOW_THREADS 
#define NPY_END_ALLOW_THREADS 
#define NPY_BEGIN_THREADS_DEF
#define NPY_BEGIN_THREADS
#define NPY_END_THREADS
#define NPY_BEGIN_THREADS_DESCR(dtype)
#define NPY_END_THREADS_DESCR(dtype)
#define NPY_ALLOW_C_API_DEF
#define	NPY_ALLOW_C_API
#define	NPY_DISABLE_C_API
#endif

typedef struct {
        PyObject_HEAD
	int               nd_m1;            /* number of dimensions - 1 */
        npy_intp	  index, size;
	npy_intp          coordinates[NPY_MAXDIMS];/* N-dimensional loop */
        npy_intp          dims_m1[NPY_MAXDIMS];    /* ao->dimensions - 1 */
	npy_intp          strides[NPY_MAXDIMS];    /* ao->strides or fake */
	npy_intp          backstrides[NPY_MAXDIMS];/* how far to jump back */
	npy_intp          factors[NPY_MAXDIMS];     /* shape factors */
	PyArrayObject     *ao;
	char              *dataptr;        /* pointer to current item*/
        npy_bool          contiguous;
} PyArrayIterObject;


/* Iterator API */
#define PyArrayIter_Check(op) PyObject_TypeCheck(op, &PyArrayIter_Type)

#define PyArray_ITER_RESET(it) {					\
	it->index = 0;						        \
	it->dataptr = it->ao->data;					\
	memset(it->coordinates, 0, (it->nd_m1+1)*sizeof(npy_intp));		\
}

#define _PyArray_ITER_NEXT1(it) {		\
		it->dataptr += it->strides[0];	\
		it->coordinates[0]++;		\
	}

#define _PyArray_ITER_NEXT2(it) {					\
		if (it->coordinates[1] < it->dims_m1[1]) {		\
			it->coordinates[1]++;				\
			it->dataptr += it->strides[1];			\
		}							\
		else {							\
			it->coordinates[1] = 0;				\
			it->coordinates[0]++;				\
			it->dataptr += it->strides[0] -			\
				it->backstrides[1];			\
		}							\
	}

#define PyArray_ITER_NEXT(it) {						\
	it->index++;						        \
        if (it->nd_m1 == 0) {						\
		_PyArray_ITER_NEXT1(it);				\
	}								\
	else if (it->contiguous)  it->dataptr += it->ao->descr->elsize; \
	else if (it->nd_m1 == 1) {					\
		_PyArray_ITER_NEXT2(it);				\
	}								\
	else {								\
		int _i_;						\
		for (_i_ = it->nd_m1; _i_ >= 0; _i_--) {		\
			if (it->coordinates[_i_] <			\
			    it->dims_m1[_i_]) {				\
				it->coordinates[_i_]++;			\
				it->dataptr += it->strides[_i_];	\
				break;					\
			}						\
			else {						\
				it->coordinates[_i_] = 0;		\
				it->dataptr -= it->backstrides[_i_];	\
			}						\
		}							\
	}								\
}

#define PyArray_ITER_GOTO(it, destination) {				\
		int _i_;						\
		it->index = 0;						\
		it->dataptr = it->ao->data;				\
		for (_i_ = it->nd_m1; _i_>=0; _i_--) {			\
                        if (destination[_i_] < 0) {                     \
                                destination[_i_] += it->dims_m1[_i_]+1; \
                        }                                               \
			it->dataptr += destination[_i_] *		\
				it->strides[_i_];			\
			it->coordinates[_i_] = destination[_i_];	\
			it->index += destination[_i_] *			\
				( _i_==it->nd_m1 ? 1 :			\
				  it->dims_m1[_i_+1]+1) ;		        \
		}							\
	}

#define PyArray_ITER_GOTO1D(it, ind) {                                  \
		int _i_;						\
		npy_intp _lind_ = (npy_intp) (ind);				\
                if (_lind_ < 0) _lind_ += it->size;                     \
		it->index = _lind_;					\
                if (it->nd_m1 == 0) {                                   \
                        it->dataptr = it->ao->data + _lind_ *           \
                                it->strides[0];                         \
                }                                                       \
                else if (it->contiguous)                                \
			it->dataptr = it->ao->data + _lind_ *		\
				it->ao->descr->elsize;			\
		else {							\
			it->dataptr = it->ao->data;			\
			for (_i_ = 0; _i_<=it->nd_m1; _i_++) {		\
				it->dataptr += (_lind_ / it->factors[_i_]) \
					* it->strides[_i_];		\
				_lind_ %= it->factors[_i_];		\
			}						\
		}							\
}

#define PyArray_ITER_DATA(it) ((PyArrayIterObject *)it)->dataptr


/*
   Any object passed to PyArray_Broadcast must be binary compatible with
   this structure.
*/

typedef struct {
	PyObject_HEAD
	int                  numiter;                 /* number of iters */
	npy_intp             size;                    /* broadcasted size */
	npy_intp             index;                   /* current index */
	int                  nd;                      /* number of dims */
	npy_intp             dimensions[NPY_MAXDIMS]; /* dimensions */
	PyArrayIterObject    *iters[NPY_MAXDIMS];     /* iterators */
} PyArrayMultiIterObject;

#define PyArray_MultiIter_RESET(multi) {			  \
		int _mi_;					  \
		PyArrayMultiIterObject *_mul_ = (multi);	  \
		_mul_->index = 0;				  \
		for (_mi_ = 0; _mi_ < _mul_->numiter; _mi_++) {	  \
			PyArray_ITER_RESET(_mul_->iters[_mi_]);	  \
		}						  \
	}

#define PyArray_MultiIter_NEXT(multi) {				 \
		int _mi_;					 \
		PyArrayMultiIterObject *_mul_ = (multi);	  \
		_mul_->index += 1;				 \
		for (_mi_=0; _mi_<_mul_->numiter; _mi_++) {	 \
			PyArray_ITER_NEXT(_mul_->iters[_mi_]);	 \
		}						 \
	}

#define PyArray_MultiIter_GOTO(multi, dest) {				\
		int _mi_;						\
		PyArrayMultiIterObject *_mul_ = (multi);		\
		for (_mi_=0; _mi_<_mul_->numiter; _mi_++) {		\
			PyArray_ITER_GOTO(_mul_->iters[_mi_], dest);	\
		}							\
		_mul_->index = _mul_->iters[0]->index;			\
	}

#define PyArray_MultiIter_GOTO1D(multi, ind) {				\
		int _mi_;						\
		PyArrayMultiIterObject *_mul_ = (multi);		\
		for (_mi_=0; _mi_<_mul_->numiter; _mi_++) {		\
			PyArray_ITER_GOTO1D(_mul_->iters[_mi_], ind);	\
		}							\
		_mul_->index = _mul_->iters[0]->index;			\
	}

#define PyArray_MultiIter_DATA(multi, i) \
	((PyArrayMultiIterObject *)multi)->iters[i]->dataptr

#define PyArray_MultiIter_SIZE(multi) \
	((PyArrayMultiIterObject *)multi)->size;


/* Store the information needed for fancy-indexing over an array */

typedef struct {
	PyObject_HEAD
	/* Multi-iterator portion --- needs to be present in this order to
	   work with PyArray_Broadcast */

	int                   numiter;                 /* number of index-array
							  iterators */
	npy_intp              size;                    /* size of broadcasted
							  result */
	npy_intp              index;                   /* current index */
	int                   nd;                      /* number of dims */
	npy_intp              dimensions[NPY_MAXDIMS]; /* dimensions */
	PyArrayIterObject     *iters[NPY_MAXDIMS];     /* index object
							  iterators */
	PyArrayIterObject     *ait;                    /* flat Iterator for
							  underlying array */

	/* flat iterator for subspace (when numiter < nd) */
	PyArrayIterObject     *subspace;

	/* if subspace iteration, then this is the array of
	   axes in the underlying array represented by the
	   index objects */
	int                   iteraxes[NPY_MAXDIMS];
	/* if subspace iteration, the these are the coordinates
	   to the start of the subspace.
	*/
	npy_intp              bscoord[NPY_MAXDIMS];

	PyObject              *indexobj;               /* creating obj */
	int                   view;
	int                   consec;
	char                  *dataptr;

} PyArrayMapIterObject;

/* The default array type
 */
#define NPY_DEFAULT_TYPE NPY_DOUBLE
#define PyArray_DEFAULT NPY_DEFAULT_TYPE
/* All sorts of useful ways to look into a PyArrayObject.
   These are the recommended over casting to PyArrayObject and accessing
   the members directly.
 */

#define PyArray_NDIM(obj) (((PyArrayObject *)(obj))->nd)
#define PyArray_ISONESEGMENT(m) (PyArray_NDIM(m) == 0 || PyArray_CHKFLAGS(m, NPY_CONTIGUOUS) || \
				 PyArray_CHKFLAGS(m, NPY_FORTRAN))
#define PyArray_ISFORTRAN(m) (PyArray_CHKFLAGS(m, NPY_FORTRAN) && (PyArray_NDIM(m) > 1))
#define PyArray_FORTRAN_IF(m) ((PyArray_CHKFLAGS(m, NPY_FORTRAN) ? NPY_FORTRAN : 0))
#define FORTRAN_IF PyArray_FORTRAN_IF
#define PyArray_DATA(obj) ((void *)(((PyArrayObject *)(obj))->data))
#define PyArray_BYTES(obj) (((PyArrayObject *)(obj))->data)
#define PyArray_DIMS(obj) (((PyArrayObject *)(obj))->dimensions)
#define PyArray_STRIDES(obj) (((PyArrayObject *)(obj))->strides)
#define PyArray_DIM(obj,n) (PyArray_DIMS(obj)[n])
#define PyArray_STRIDE(obj,n) (PyArray_STRIDES(obj)[n])
#define PyArray_BASE(obj) (((PyArrayObject *)(obj))->base)
#define PyArray_DESCR(obj) (((PyArrayObject *)(obj))->descr)
#define PyArray_FLAGS(obj) (((PyArrayObject *)(obj))->flags)
#define PyArray_ITEMSIZE(obj) (((PyArrayObject *)(obj))->descr->elsize)
#define PyArray_TYPE(obj) (((PyArrayObject *)(obj))->descr->type_num)
#define PyArray_GETITEM(obj,itemptr)			\
	((PyArrayObject *)(obj))->descr->f->getitem((char *)itemptr,	\
						 (PyArrayObject *)obj);
#define PyArray_SETITEM(obj,itemptr,v)					\
	(obj)->descr->f->setitem((PyObject *)v,(char *)(itemptr),		\
			      (PyArrayObject *)(obj));


#define PyTypeNum_ISBOOL(type) (type == NPY_BOOL)
#define PyTypeNum_ISUNSIGNED(type) ((type == NPY_UBYTE) || \
				 (type == NPY_USHORT) || \
				 (type == NPY_UINT) ||	\
				 (type == NPY_ULONG) || \
				 (type == NPY_ULONGLONG))

#define PyTypeNum_ISSIGNED(type) ((type == NPY_BYTE) ||	\
			       (type == NPY_SHORT) ||	\
			       (type == NPY_INT) ||	\
			       (type == NPY_LONG) ||	\
			       (type == NPY_LONGLONG))

#define PyTypeNum_ISINTEGER(type) ((type >= NPY_BYTE) &&	\
				(type <= NPY_ULONGLONG))

#define PyTypeNum_ISFLOAT(type) ((type >= NPY_FLOAT) &&  \
			      (type <= NPY_LONGDOUBLE))

#define PyTypeNum_ISNUMBER(type) (type <= NPY_CLONGDOUBLE)

#define PyTypeNum_ISSTRING(type) ((type == NPY_STRING) || \
			       (type == NPY_UNICODE))

#define PyTypeNum_ISCOMPLEX(type) ((type >= NPY_CFLOAT) && \
				(type <= NPY_CLONGDOUBLE))

#define PyTypeNum_ISPYTHON(type) ((type == NPY_LONG) || \
				  (type == NPY_DOUBLE) ||	\
				  (type == NPY_CDOUBLE) ||	\
		                  (type == NPY_BOOL) || \
				  (type == NPY_OBJECT ))

#define PyTypeNum_ISFLEXIBLE(type) ((type>=NPY_STRING) && \
				    (type<=NPY_VOID))

#define PyTypeNum_ISUSERDEF(type) ((type >= NPY_USERDEF) && \
				   (type < NPY_USERDEF+\
				    NPY_NUMUSERTYPES))

#define PyTypeNum_ISEXTENDED(type) (PyTypeNum_ISFLEXIBLE(type) ||  \
                                    PyTypeNum_ISUSERDEF(type))

#define PyTypeNum_ISOBJECT(type) ((type) == NPY_OBJECT)


#define PyDataType_ISBOOL(obj) PyTypeNum_ISBOOL(_PyADt(obj))
#define PyDataType_ISUNSIGNED(obj) PyTypeNum_ISUNSIGNED(((PyArray_Descr*)obj)->type_num)
#define PyDataType_ISSIGNED(obj) PyTypeNum_ISSIGNED(((PyArray_Descr*)obj)->type_num)
#define PyDataType_ISINTEGER(obj) PyTypeNum_ISINTEGER(((PyArray_Descr*)obj)->type_num )
#define PyDataType_ISFLOAT(obj) PyTypeNum_ISFLOAT(((PyArray_Descr*)obj)->type_num)
#define PyDataType_ISNUMBER(obj) PyTypeNum_ISNUMBER(((PyArray_Descr*)obj)->type_num)
#define PyDataType_ISSTRING(obj) PyTypeNum_ISSTRING(((PyArray_Descr*)obj)->type_num)
#define PyDataType_ISCOMPLEX(obj) PyTypeNum_ISCOMPLEX(((PyArray_Descr*)obj)->type_num)
#define PyDataType_ISPYTHON(obj) PyTypeNum_ISPYTHON(((PyArray_Descr*)obj)->type_num)
#define PyDataType_ISFLEXIBLE(obj) PyTypeNum_ISFLEXIBLE(((PyArray_Descr*)obj)->type_num)
#define PyDataType_ISUSERDEF(obj) PyTypeNum_ISUSERDEF(((PyArray_Descr*)obj)->type_num)
#define PyDataType_ISEXTENDED(obj) PyTypeNum_ISEXTENDED(((PyArray_Descr*)obj)->type_num)
#define PyDataType_ISOBJECT(obj) PyTypeNum_ISOBJECT(((PyArray_Descr*)obj)->type_num)
#define PyDataType_HASFIELDS(obj) (((PyArray_Descr *)obj)->names)

#define PyArray_ISBOOL(obj) PyTypeNum_ISBOOL(PyArray_TYPE(obj))
#define PyArray_ISUNSIGNED(obj) PyTypeNum_ISUNSIGNED(PyArray_TYPE(obj))
#define PyArray_ISSIGNED(obj) PyTypeNum_ISSIGNED(PyArray_TYPE(obj))
#define PyArray_ISINTEGER(obj) PyTypeNum_ISINTEGER(PyArray_TYPE(obj))
#define PyArray_ISFLOAT(obj) PyTypeNum_ISFLOAT(PyArray_TYPE(obj))
#define PyArray_ISNUMBER(obj) PyTypeNum_ISNUMBER(PyArray_TYPE(obj))
#define PyArray_ISSTRING(obj) PyTypeNum_ISSTRING(PyArray_TYPE(obj))
#define PyArray_ISCOMPLEX(obj) PyTypeNum_ISCOMPLEX(PyArray_TYPE(obj))
#define PyArray_ISPYTHON(obj) PyTypeNum_ISPYTHON(PyArray_TYPE(obj))
#define PyArray_ISFLEXIBLE(obj) PyTypeNum_ISFLEXIBLE(PyArray_TYPE(obj))
#define PyArray_ISUSERDEF(obj) PyTypeNum_ISUSERDEF(PyArray_TYPE(obj))
#define PyArray_ISEXTENDED(obj) PyTypeNum_ISEXTENDED(PyArray_TYPE(obj))
#define PyArray_ISOBJECT(obj) PyTypeNum_ISOBJECT(PyArray_TYPE(obj))
#define PyArray_HASFIELDS(obj) PyDataType_HASFIELDS(PyArray_DESCR(obj))

#define NPY_LITTLE '<'
#define NPY_BIG '>'
#define NPY_NATIVE '='
#define NPY_SWAP 's'
#define NPY_IGNORE '|'

#ifdef WORDS_BIGENDIAN
#define NPY_NATBYTE NPY_BIG
#define NPY_OPPBYTE NPY_LITTLE
#else
#define NPY_NATBYTE NPY_LITTLE
#define NPY_OPPBYTE NPY_BIG
#endif

#define PyArray_ISNBO(arg) ((arg) != NPY_OPPBYTE)
#define PyArray_IsNativeByteOrder PyArray_ISNBO
#define PyArray_ISNOTSWAPPED(m) PyArray_ISNBO(PyArray_DESCR(m)->byteorder)
#define PyArray_ISBYTESWAPPED(m) (!PyArray_ISNOTSWAPPED(m))

#define PyArray_FLAGSWAP(m, flags) (PyArray_CHKFLAGS(m, flags) &&	\
				    PyArray_ISNOTSWAPPED(m))
#define PyArray_ISCARRAY(m) PyArray_FLAGSWAP(m, NPY_CARRAY)
#define PyArray_ISCARRAY_RO(m) PyArray_FLAGSWAP(m, NPY_CARRAY_RO)
#define PyArray_ISFARRAY(m) PyArray_FLAGSWAP(m, NPY_FARRAY)
#define PyArray_ISFARRAY_RO(m) PyArray_FLAGSWAP(m, NPY_FARRAY_RO)
#define PyArray_ISBEHAVED(m) PyArray_FLAGSWAP(m, NPY_BEHAVED)
#define PyArray_ISBEHAVED_RO(m) PyArray_FLAGSWAP(m, NPY_ALIGNED)



/* This is the form of the struct that's returned pointed by the
   PyCObject attribute of an array __array_struct__. See
   http://numeric.scipy.org/array_interface.html for the full
   documentation. */
typedef struct {
    int two;              /* contains the integer 2 as a sanity check */
    int nd;               /* number of dimensions */
    char typekind;        /* kind in array --- character code of typestr */
    int itemsize;         /* size of each element */
    int flags;            /* how should be data interpreted. Valid
                             flags are CONTIGUOUS (1), FORTRAN (2),
                             ALIGNED (0x100), NOTSWAPPED (0x200), and
                             WRITEABLE (0x400). 
			     ARR_HAS_DESCR (0x800) states that arrdescr
                                field is present in structure */
    npy_intp *shape;          /* A length-nd array of shape information */
    npy_intp *strides;        /* A length-nd array of stride information */
    void *data;           /* A pointer to the first element of the array */
    PyObject *descr;      /* A list of fields or NULL (ignored if flags
                                does not have ARR_HAS_DESCR flag set) */
} PyArrayInterface;

/* Includes the "function" C-API -- these are all stored in a
   list of pointers --- one for each file
   The two lists are concatenated into one in multiarray.

   They are available as import_array()
*/


#include "__multiarray_api.h"


/* C-API that requries previous API to be defined */

#define PyArray_DescrCheck(op) ((op)->ob_type == &PyArrayDescr_Type)

#define PyArray_Check(op) ((op)->ob_type == &PyArray_Type ||		\
			   PyObject_TypeCheck((op), &PyArray_Type))
#define PyArray_CheckExact(op) ((op)->ob_type == &PyArray_Type)

#define PyArray_IsZeroDim(op) (PyArray_Check(op) && (PyArray_NDIM(op) == 0))
#define PyArray_IsScalar(obj, cls)				\
	(PyObject_TypeCheck((obj), &Py##cls##ArrType_Type))
#define PyArray_CheckScalar(m) (PyArray_IsScalar(m, Generic) || \
                                PyArray_IsZeroDim(m))
#define PyArray_IsPythonNumber(obj) \
	(PyInt_Check(obj) || PyFloat_Check(obj) || PyComplex_Check(obj) || \
	 PyLong_Check(obj) || PyBool_Check(obj))
#define PyArray_IsPythonScalar(obj) \
	(PyArray_IsPythonNumber(obj) || PyString_Check(obj) ||  \
         PyUnicode_Check(obj))
#define PyArray_IsAnyScalar(obj)					\
	(PyArray_IsScalar(obj, Generic) || PyArray_IsPythonScalar(obj))
#define PyArray_CheckAnyScalar(obj) (PyArray_IsPythonScalar(obj) || \
				     PyArray_CheckScalar(obj))

#define PyArray_GETCONTIGUOUS(m) (PyArray_ISCONTIGUOUS(m) ? Py_INCREF(m), m : \
                                  (PyArrayObject *)(PyArray_Copy(m)))

#define PyArray_SAMESHAPE(a1,a2) ((PyArray_NDIM(a1) == PyArray_NDIM(a2)) && \
				  PyArray_CompareLists(PyArray_DIMS(a1), \
						       PyArray_DIMS(a2), \
						       PyArray_NDIM(a1)))
#define PyArray_SIZE(m) PyArray_MultiplyList(PyArray_DIMS(m), PyArray_NDIM(m))
#define PyArray_NBYTES(m) (PyArray_ITEMSIZE(m) * PyArray_SIZE(m))
#define PyArray_FROM_O(m) PyArray_FromAny(m, NULL, 0, 0, 0, NULL)
#define PyArray_FROM_OF(m,flags) PyArray_CheckFromAny(m, NULL, 0, 0, flags, NULL)
#define PyArray_FROM_OT(m,type) PyArray_FromAny(m, PyArray_DescrFromType(type), \
                                                      0, 0, 0, NULL);
#define PyArray_FROM_OTF(m, type, flags)                                \
	PyArray_FromAny(m, PyArray_DescrFromType(type), 0, 0,           \
                        (((flags) & NPY_ENSURECOPY) ?                       \
                         ((flags) | NPY_DEFAULT) : (flags)), NULL)
#define PyArray_FROMANY(m, type, min, max, flags)                       \
	PyArray_FromAny(m, PyArray_DescrFromType(type), min, max,       \
                        (((flags) & NPY_ENSURECOPY) ?                       \
                         (flags) | NPY_DEFAULT : (flags)), NULL)
#define PyArray_ZEROS(m, dims, type, fortran) \
	PyArray_Zeros(m, dims, PyArray_DescrFromType(type), fortran)
#define PyArray_EMPTY(m, dims, type, fortran) \
	PyArray_Empty(m, dims, PyArray_DescrFromType(type), fortran)

#define PyArray_FILLWBYTE(obj, val) memset(PyArray_DATA(obj), (val), PyArray_NBYTES(obj))

#define PyArray_REFCOUNT(obj) (((PyObject *)(obj))->ob_refcnt)
#define NPY_REFCOUNT PyArray_REFCOUNT
#define NPY_MAX_ELSIZE 2*SIZEOF_LONGDOUBLE

#define PyArray_ContiguousFromAny(op, type, min_depth, max_depth)   \
        PyArray_FromAny(op, PyArray_DescrFromType(type), min_depth, \
                              max_depth, NPY_DEFAULT, NULL)

#define PyArray_EquivArrTypes(a1, a2)					\
	PyArray_EquivTypes(PyArray_DESCR(a1), PyArray_DESCR(a2))

#define PyArray_EquivByteorders(b1, b2) \
	(((b1) == (b2)) || (PyArray_ISNBO(b1) == PyArray_ISNBO(b2)))

#define PyArray_SimpleNew(nd, dims, typenum) \
	PyArray_New(&PyArray_Type, nd, dims, typenum, NULL, NULL, 0, 0, NULL)
#define PyArray_SimpleNewFromData(nd, dims, typenum, data) \
        PyArray_New(&PyArray_Type, nd, dims, typenum, NULL, data, 0, NPY_CARRAY, NULL)
#define PyArray_SimpleNewFromDescr(nd, dims, descr) \
	PyArray_NewFromDescr(&PyArray_Type, descr, nd, dims, NULL, NULL, 0, NULL)

#define PyArray_ToScalar(data, arr) \
	PyArray_Scalar(data, PyArray_DESCR(arr), (PyObject *)arr)

/* These might be faster without the dereferencing of obj
   going on inside -- of course an optimizing compiler should
   inline the constants inside a for loop making it a moot point
*/

#define PyArray_GETPTR1(obj, i) (void *)(PyArray_BYTES(obj) +		\
					 i*PyArray_STRIDES(obj)[0])

#define PyArray_GETPTR2(obj, i, j) (void *)(PyArray_BYTES(obj) +	\
					    i*PyArray_STRIDES(obj)[0] +	\
					    j*PyArray_STRIDES(obj)[1])

#define PyArray_GETPTR3(obj, i, j, k) (void *)(PyArray_BYTES(obj) +	\
					       i*PyArray_STRIDES(obj)[0] + \
					       j*PyArray_STRIDES(obj)[1] + \
					       k*PyArray_STRIDES(obj)[2]) \

#define PyArray_GETPTR4(obj, i, j, k, l) (void *)(PyArray_BYTES(obj) +	\
						  i*PyArray_STRIDES(obj)[0] + \
						  j*PyArray_STRIDES(obj)[1] + \
						  k*PyArray_STRIDES(obj)[2] + \
						  l*PyArray_STRIDES(obj)[3])

#define PyArray_XDECREF_ERR(obj) \
	if (obj && (PyArray_FLAGS(obj) & NPY_UPDATEIFCOPY)) {      \
		PyArray_FLAGS(PyArray_BASE(obj)) |= NPY_WRITEABLE; \
		PyArray_FLAGS(obj) &= ~NPY_UPDATEIFCOPY; \
	}\
	Py_XDECREF(obj)

#define PyArray_DESCR_REPLACE(descr) do {	\
		PyArray_Descr *_new_;			\
		_new_ = PyArray_DescrNew(descr);	\
		Py_XDECREF(descr);			\
		descr = _new_;				\
	} while(0)

/* Copy should always return contiguous array */
#define PyArray_Copy(obj) PyArray_NewCopy(obj, NPY_CORDER)

#define PyArray_FromObject(op, type, min_depth, max_depth)		\
	PyArray_FromAny(op, PyArray_DescrFromType(type), min_depth,	\
                              max_depth, NPY_BEHAVED | NPY_ENSUREARRAY, NULL)

#define PyArray_ContiguousFromObject(op, type, min_depth, max_depth)	\
        PyArray_FromAny(op, PyArray_DescrFromType(type), min_depth,	\
                              max_depth, NPY_DEFAULT | NPY_ENSUREARRAY, NULL)

#define PyArray_CopyFromObject(op, type, min_depth, max_depth)		\
        PyArray_FromAny(op, PyArray_DescrFromType(type), min_depth,     \
                        max_depth, NPY_ENSURECOPY | NPY_DEFAULT | NPY_ENSUREARRAY, NULL)

#define PyArray_Cast(mp, type_num) \
	PyArray_CastToType(mp, PyArray_DescrFromType(type_num), 0)

/* Compatibility with old Numeric stuff -- don't use in new code */

#define PyArray_FromDimsAndData(nd, d, type, data) \
	PyArray_FromDimsAndDataAndDescr(nd, d, PyArray_DescrFromType(type), \
					data)

#include "old_defines.h"

#ifdef __cplusplus
}
#endif

#endif /* !Py_ARRAYOBJECT_H */
