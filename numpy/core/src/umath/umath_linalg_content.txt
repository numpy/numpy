			   *** Changes ***
2012-11-13 Added mention to gufuncs_linalg wrapper module.
	   Added a nose test module for gufuncs_linalg. Implemented several test.
               Tests are now work in progress.
	   Fixed bugs in the harness of gufuncs (related to the signature fix)
	   Fixed several other small bugs found by the new tests. Mostly in the
               complex versions of the functions.
	   Known problems in (working in fixing them:
               Matrix Multiply when the parameter types are cdouble
               EigVals is causing problems when the parameter types are csingle
			   ***************

			 umath_linalg module

This module provides gufuncs for several functions that were already present in
numpy.linalg. There are some extra functions thrown in.

Having them as gufuncs allows broadcasting of calls, which can be useful when 
there are various problems to solve.

The functions are members of a module currently at numpy.core.umath_linalg

A wrapper module is provides that works around some limitations on the handling
of keyword parameters in gufuncs by adding a very thin python layer around the
actual gufuncs. For example, chosolve is implemented as a wrapper that takes a
keyword parameter "UPLO". Depending on its value the appropriate gufunc will be
called (chosolve_up or chosolve_lo). The wrapper module is 
numpy.core.gufuncs_linalg and should be preferred to direct umath_linalg calls.
Note that this wrapper module is written in python and its contents should be
easy to inspect.

			       Contents
The following functions are already implemented:

- inner1d: (n),(n) -> ()
  dot product of the vectors in the inner dimension. Uses BLAS.
- inner2d: (n),(n),(n) -> ()
  u,v,w being the inputs: sum(u[i]*v[i]*w[i]) for all i in n. Copied for 
  convenience from umath_tests
- matrix_multiply: (m,k),(k,n) -> (m,n)
  matrix multiplication. Uses BLAS.
- slogdet: (m,m)->(),()
  sign and logarithm of the determinant of the input. Uses LAPACK.
- det: (m,m)->()
  determinant of the input, computed using slogdet and thus, uses LAPACK.
- eigh_lo: (m,n)->(m)(m,n)
  eigenvalues and eigenvectors of symmetric/hermitian matrices, encoded in the
  lower diagonal. Uses LAPACK.
- eigh_up: (m,m)->(m)(m,m)
  eigenvalues and eigenvectors of symmetric/hermitian matrices, encoded in the
  upper diagonal. Uses LAPACK.
- eigvalsh_lo: (m,m)->(m)
  eigenvalues of symmetric/hermitian matrices, encoded in the lower triangular
  part. Uses LAPACK.
- eigvalsh_up: (m,m)->(m)
  eigenvalues of symmetric/hermitian matrices, encoded in the upper triangular
  part. Uses LAPACK.
- solve: (m,m),(m,n)->(m,n)
  Solve X for a system AX=B, X and B being matrices. Uses LAPACK.
- solve1: (m,m),(m)->(m)
  Solve x for a system Ax=b, x and b being vectors. Uses LAPACK.
- inv: (m,m)->(m,m)
  Compute the inverse of a matrix. Implemented using solve. Uses LAPACK.
- cholesky: (m,m)->(m,m)
  Perform cholesky decomposition of hermitian positive-definite matrices.
  The lower diagonal of the input matrix is used. Uses LAPACK.
- svd_m: (m,n)->(m)
  singular value decomposition of the input matrix. Use this function when
  m<=n and only the singular values are needed. Uses LAPACK.
- svd_n: (m,n)->(n)
  singular value decomposition of the input matrix. Use this function when
  m>=n and only the singular values are needed. Uses LAPACK.
- svd_m_s, svd_m_f, svd_n_s, svd_n_f *
  singular value decomposition resulting in U s V. See note on svd.
- eig: (m,m)->(m),(m,m)
  eigenvalues and eigenvectors of general matrices. Uses LAPACK.
- eigvals; (m,m)->(m)
  eigenvalues of general matrices. Uses LAPACK.
- quadratic_form: (m),(m,n),(n)->()
  computes the quadratic form uQv. Uses BLAS.
- add3: (),(),()->()
  3-way element-wise addition.
- multiply3: (),(),()->()
  3-way element-wise product.
- multiply3_add: (),(),(),()->()
  3-way element-wise product plus addition.
- multply_add: (),(),()->()
  element-wise multiply add.
- multiply_add2: (),(),(),()->()
  element-wise product with 2 additions.
- multiply4: (),(),(),()->()
  4-way element-wise product.
- multiply4_add: (),(),(),(),()->()
  4-way element-wise product plus addition.
- chosolve_lo
  solve a system AX=B where A is symmetric/hermitian (using lapack potrf, potrs on the
  lower triangle)
- chosolve_up
  solve a system AX=B where A is symmetric/hermitian (using lapack potrf, potrs on the
  upper triangle)
- chosolve1_lo
  solve a system Ax=b where A is symmetric/hermitian (using lapack potrf, potrs on the
  lower triangle)
- chosolve1_up
  solve a system Ax=b where A is symmetric/hermitian (using lapack potrf, potrs on the
  upper triangle)
- poinv_lo
  compute the inverse of a positive definite symmetric/hermitian matrix (using lapack 
  ptorf, potri on the lower triangle)
- poinv_up
  compute the inverse of a positive definite symmetric/hermitian matrix (using lapack 
  ptorf, potri on the upper triangle)

		    Note on uniform parameters
There are some configuration parameters in some of the functions in the linalg
module that configure how some computation is to be done. Examples are eigh and
eigvalsh, that take an optional keywork parameter that allows to specify 
whether to use the upper or the lower triangular part (UPLO). That parameter is
considered uniform for all broadcast operations. As in the gufunc interface
there is no way to specify uniform parameters, it has been encoded in the gufunc
name, so for eigh we have the functions eigh_lo and eigh_up (for 'L' and 'U').

Similar techniques have been applied in other places.

Note that this is hidden when using the gufuncs_linalg wrapper module.

			     Note on svd
svd uses uniform parameters to specify the result types it will be producing
(full_matrices and compute_uv in numpy.linalg).
svd is also special in the sense that the signature of the function depends on
the size of the parameters, as for a matrix m by n, the result is a vector with
min(m,n) values. This is not supported by the gufunc harness, so specialized
versions of the gufunc are provided that encode whether m<n or m>n, so they
can specify the signature accordingly. This is also encoded in the gufunc name.

The function to use, in pseudocode, would be:

func = 'svd'
if (m < n):
   func += '_m'
else:
   func += '_n'

if compute_uv:
   if full_matrices:
      func += '_f'
   else:
      func += '_s'

This should be transparent when using the gufuncs_linalg module.

		     Bug in numpy gufunc harness
The bug in the gufunc harness that was preventing using a dimension name more than
once in a single operand has been fixed. This bug was preventing some versions of
svd to be functional. It also meant that some other gufuncs that required square
matrices where implemented with signatures that did not enforce the matrices to be
square, resulting in undefined behavior if the kernel was applied in non-square
kernels.

The signatures of gufuncs that expect square matrices have been updated so that the
harness enforces the squareness of the arguments.

