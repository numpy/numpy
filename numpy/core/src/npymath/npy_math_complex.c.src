/*
 * vim: syntax=c
 *
 * Implement some C99-compatible complex math functions
 *
 * Most of the code is taken from the msun library in FreeBSD (HEAD @ 30th June
 * 2009), under the following license:
 *
 * Copyright (c) 2007, 2011 David Schultz <das@FreeBSD.ORG>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "npy_math_common.h"
#include "npy_math_private.h"

/**begin repeat
 * #type = npy_float, npy_double, npy_longdouble#
 * #ctype = npy_cfloat,npy_cdouble,npy_clongdouble#
 * #c = f, , l#
 * #C = F, , L#
 * #TMAX = FLT_MAX, DBL_MAX, LDBL_MAX#
 * #TMIN = FLT_MIN, DBL_MIN, LDBL_MIN#
 * #TMANT_DIG = FLT_MANT_DIG, DBL_MANT_DIG, LDBL_MANT_DIG#
 * #precision = 1, 2, 3#
 */

/*==========================================================
 * Constants
 *=========================================================*/
static const @ctype@ c_1@c@ = {1.0@C@, 0.0};
static const @ctype@ c_half@c@ = {0.5@C@, 0.0};
static const @ctype@ c_i@c@ = {0.0, 1.0@C@};
static const @ctype@ c_ihalf@c@ = {0.0, 0.5@C@};

/*==========================================================
 * Helper functions
 * 
 * These are necessary because we do not count on using a 
 * C99 compiler.
 *=========================================================*/
static NPY_INLINE @ctype@ cadd@c@(@ctype@ a, @ctype@ b)
{
    return npy_cpack@c@(npy_creal@c@(a) + npy_creal@c@(b),
                        npy_cimag@c@(a) + npy_cimag@c@(b));
}

static NPY_INLINE @ctype@ csub@c@(@ctype@ a, @ctype@ b)
{
    return npy_cpack@c@(npy_creal@c@(a) - npy_creal@c@(b),
                        npy_cimag@c@(a) - npy_cimag@c@(b));
}

static NPY_INLINE @ctype@ cmul@c@(@ctype@ a, @ctype@ b)
{
    @type@ ar, ai, br, bi;
    ar = npy_creal@c@(a);
    ai = npy_cimag@c@(a);
    br = npy_creal@c@(b);
    bi = npy_cimag@c@(b);
    return npy_cpack@c@(ar*br - ai*bi, ar*bi + ai*br);
}

static NPY_INLINE @ctype@ cdiv@c@(@ctype@ a, @ctype@ b)
{
    @type@ ar, ai, br, bi, abs_br, abs_bi;
    ar = npy_creal@c@(a);
    ai = npy_cimag@c@(a);
    br = npy_creal@c@(b);
    bi = npy_cimag@c@(b);
    abs_br = npy_fabs@c@(br);
    abs_bi = npy_fabs@c@(bi);

    if (abs_br >= abs_bi) {
        if (abs_br == 0 && abs_bi == 0) {
            /* divide by zeros should yield a complex inf or nan */
            return npy_cpack@c@(ar/abs_br, ai/abs_bi);
        }
        else {
            @type@ rat = bi/br;
            @type@ scl = 1.0@C@/(br+bi*rat);
            return npy_cpack@c@((ar + ai*rat)*scl, (ai - ar*rat)*scl);
        }
    }
    else {
        @type@ rat = br/bi;
        @type@ scl = 1.0@C@/(bi + br*rat);
        return npy_cpack@c@((ar*rat + ai)*scl, (ai*rat - ar)*scl);
    }
}
    
static NPY_INLINE @ctype@ cneg@c@(@ctype@ a)
{
    return npy_cpack@c@(-npy_creal@c@(a), -npy_cimag@c@(a));
}

static NPY_INLINE @ctype@ cmuli@c@(@ctype@ a)
{
    return npy_cpack@c@(-npy_cimag@c@(a), npy_creal@c@(a));
}

/*
 * Perform the operation result := 1 + coef * x * result,
 * with real coefficient `coef`.
 */
#define SERIES_HORNER_TERM@C@(r, x, c)                          \
    do {                                                        \
        r = cmul@c@(r, x);                                      \
        r = npy_cpack@c@(c*npy_creal@c@(r), c*npy_cimag@c@(r)); \
        r = cadd@c@(c_1@c@, r);                                 \
    } while(0)

/*==========================================================
 * Custom implementation of missing complex C99 functions
 *=========================================================*/

#ifndef HAVE_CABS@C@
@type@ npy_cabs@c@(@ctype@ z)
{
    return npy_hypot@c@(npy_creal@c@(z), npy_cimag@c@(z));
}
#endif

#ifndef HAVE_CARG@C@
@type@ npy_carg@c@(@ctype@ z)
{
    return npy_atan2@c@(npy_cimag@c@(z), npy_creal@c@(z));
}
#endif

/* cexp and (ccos, csin)h functions need to calculate exp scaled by another
 * number.  This can be difficult if exp(x) overflows.  By doing this way, we
 * don't risk overflowing exp. This likely raises floating-point exceptions,
 * if we decide that we care.
 *
 * This is only useful over a limited range, (see below) an expects that the
 * input values are in this range.
 *
 * This is based on the technique used in FreeBSD's __frexp_exp and
 * __ldexp_(c)exp functions by David Schultz.
 *
 * SCALED_CEXP_LOWER = log(FLT_MAX)
 * SCALED_CEXP_UPPER = log(2) + log(FLT_MAX) - log(FLT_TRUE_MIN),
 * where FLT_TRUE_MIN is the smallest possible subnormal number.
 */

#define SCALED_CEXP_LOWERF 88.722839f
#define SCALED_CEXP_UPPERF 192.69492f
#define SCALED_CEXP_LOWER 710.47586007394386
#define SCALED_CEXP_UPPER 1454.9159319953251
#define SCALED_CEXP_LOWERL 11357.216553474703895L
#define SCALED_CEXP_UPPERL 22756.021937783004509L

static @ctype@ _npy_scaled_cexp@c@(@type@ x, @type@ y, npy_int expt)
{
#if @precision@ == 1
    const npy_int k = 235;
#endif
#if @precision@ == 2
    const npy_int k = 1799;
#endif
#if @precision@ == 3
    const npy_int k = 19547;
#endif
    const @type@ kln2 = k * NPY_LOGE2;
    @type@ mant, mantcos, mantsin;
    npy_int ex, excos, exsin;

    mant = npy_frexp@c@(npy_exp@c@(x - kln2), &ex);
    mantcos = npy_frexp@c@(npy_cos@c@(y), &excos);
    mantsin = npy_frexp@c@(npy_sin@c@(y), &exsin);

    expt += ex + k;
    return npy_cpack@c@( npy_ldexp@c@(mant * mantcos, expt + excos),
                         npy_ldexp@c@(mant * mantsin, expt + exsin));
}


#ifndef HAVE_CEXP@C@
@ctype@ npy_cexp@c@(@ctype@ z)
{
    @type@ x, c, s;
    @type@ r, i;
    @ctype@ ret;

    r = npy_creal@c@(z);
    i = npy_cimag@c@(z);

    if (npy_isfinite(r)) {
        if (r >= SCALED_CEXP_LOWER@C@ && r <= SCALED_CEXP_UPPER@C@) {
            ret = _npy_scaled_cexp@c@(r, i, 0);
        }
        else {
            x = npy_exp@c@(r);

            c = npy_cos@c@(i);
            s = npy_sin@c@(i);

            if (npy_isfinite(i)) {
                ret = npy_cpack@c@(x * c, x * s);
            } else {
                ret = npy_cpack@c@(NPY_NAN, npy_copysign@c@(NPY_NAN, i));
            }
        }

    } else  if (npy_isnan(r)) {
        /* r is nan */
        if (i == 0) {
            ret = z;
        } else {
            ret = npy_cpack@c@(r, npy_copysign@c@(NPY_NAN, i));
        }
    } else {
        /* r is +- inf */
        if (r > 0) {
            if (i == 0) {
                ret = npy_cpack@c@(r, i);
            } else if (npy_isfinite(i)) {
                c = npy_cos@c@(i);
                s = npy_sin@c@(i);

                ret = npy_cpack@c@(r * c, r * s);
            } else {
                /* x = +inf, y = +-inf | nan */
                npy_set_floatstatus_invalid();
                ret = npy_cpack@c@(r, NPY_NAN);
            }
        } else {
            if (npy_isfinite(i)) {
                x = npy_exp@c@(r);
                c = npy_cos@c@(i);
                s = npy_sin@c@(i);

                ret = npy_cpack@c@(x * c, x * s);
            } else {
                /* x = -inf, y = nan | +i inf */
                ret = npy_cpack@c@(0, 0);
            }
        }
    }

    return ret;
}
#endif

#ifndef HAVE_CLOG@C@
/* algorithm from cpython, rev. d86f5686cef9
 *
 * The usual formula for the real part is log(hypot(z.real, z.imag)).
 * There are four situations where this formula is potentially
 * problematic:
 * 
 * (1) the absolute value of z is subnormal.  Then hypot is subnormal,
 * so has fewer than the usual number of bits of accuracy, hence may
 * have large relative error.  This then gives a large absolute error
 * in the log.  This can be solved by rescaling z by a suitable power
 * of 2.
 * 
 * (2) the absolute value of z is greater than DBL_MAX (e.g. when both
 * z.real and z.imag are within a factor of 1/sqrt(2) of DBL_MAX)
 * Again, rescaling solves this.
 * 
 * (3) the absolute value of z is close to 1.  In this case it's
 * difficult to achieve good accuracy, at least in part because a
 * change of 1ulp in the real or imaginary part of z can result in a
 * change of billions of ulps in the correctly rounded answer.
 * 
 * (4) z = 0.  The simplest thing to do here is to call the
 * floating-point log with an argument of 0, and let its behaviour
 * (returning -infinity, signaling a floating-point exception, setting
 * errno, or whatever) determine that of c_log.  So the usual formula
 * is fine here.
*/
@ctype@ npy_clog@c@(@ctype@ z)
{
    @type@ ax = npy_fabs@c@(npy_creal@c@(z));
    @type@ ay = npy_fabs@c@(npy_cimag@c@(z));
    @type@ rr, ri;

    if (ax > @TMAX@/4 || ay > @TMAX@/4) {
        rr = npy_log@c@(npy_hypot@c@(ax/2, ay/2)) + NPY_LOGE2@c@;
    }
    else if (ax < @TMIN@ && ay < @TMIN@) {
        if (ax > 0  || ay > 0) {
            /* catch cases where hypot(ax, ay) is subnormal */
            rr = npy_log@c@(npy_hypot@c@(npy_ldexp@c@(ax, @TMANT_DIG@),
                 npy_ldexp@c@(ay, @TMANT_DIG@))) - @TMANT_DIG@*NPY_LOGE2@c@;
        }
        else {
            /* log(+/-0 +/- 0i) */
            /* raise divide-by-zero floating point exception */
            rr = -1.0@c@ / npy_creal@c@(z);
            rr = npy_copysign@c@(rr, -1);
            ri = npy_carg@c@(z);
            return npy_cpack@c@(rr, ri);
        }
    }
    else {
        @type@ h = npy_hypot@c@(ax, ay);
        if (0.71 <= h && h <= 1.73) {
            @type@ am = ax > ay ? ax : ay; /* max(ax, ay) */
            @type@ an = ax > ay ? ay : ax; /* min(ax, ay) */
            rr = npy_log1p@c@((am-1)*(am+1)+an*an)/2;
        }
        else {
            rr = npy_log@c@(h);
        }
    }
    ri = npy_carg@c@(z);
    return npy_cpack@c@(rr, ri);
}
#endif

#ifndef HAVE_CSQRT@C@

/* We risk spurious overflow for components >= DBL_MAX / (1 + sqrt(2)). */
#define THRESH  (@TMAX@ / (1 + NPY_SQRT2@c@))

@ctype@ npy_csqrt@c@(@ctype@ z)
{
    @ctype@ result;
    @type@ a, b;
    @type@ t;
    int scale;

    a = npy_creal@c@(z);
    b = npy_cimag@c@(z);

    /* Handle special cases. */
    if (a == 0 && b == 0)
        return (npy_cpack@c@(0, b));
    if (npy_isinf(b))
        return (npy_cpack@c@(NPY_INFINITY, b));
    if (npy_isnan(a)) {
        t = (b - b) / (b - b);  /* raise invalid if b is not a NaN */
        return (npy_cpack@c@(a, t));    /* return NaN + NaN i */
    }
    if (npy_isinf(a)) {
        /*
         * csqrt(inf + NaN i)  = inf +  NaN i
         * csqrt(inf + y i)    = inf +  0 i
         * csqrt(-inf + NaN i) = NaN +- inf i
         * csqrt(-inf + y i)   = 0   +  inf i
         */
        if (npy_signbit(a))
            return (npy_cpack@c@(npy_fabs@c@(b - b), npy_copysign@c@(a, b)));
        else
            return (npy_cpack@c@(a, npy_copysign@c@(b - b, b)));
    }
    /*
     * The remaining special case (b is NaN) is handled just fine by
     * the normal code path below.
     */

    /* Scale to avoid overflow. */
    if (npy_fabs@c@(a) >= THRESH || npy_fabs@c@(b) >= THRESH) {
        a *= 0.25;
        b *= 0.25;
        scale = 1;
    } else {
        scale = 0;
    }

    /* Algorithm 312, CACM vol 10, Oct 1967. */
    if (a >= 0) {
        t = npy_sqrt@c@((a + npy_hypot@c@(a, b)) * 0.5);
        result = npy_cpack@c@(t, b / (2 * t));
    } else {
        t = npy_sqrt@c@((-a + npy_hypot@c@(a, b)) * 0.5);
        result = npy_cpack@c@(npy_fabs@c@(b) / (2 * t), npy_copysign@c@(t, b));
    }

    /* Rescale. */
    if (scale)
        return (npy_cpack@c@(npy_creal@c@(result) * 2, npy_cimag@c@(result)));
    else
        return (result);
}
#undef THRESH
#endif

#ifndef HAVE_CPOW@C@
@ctype@ npy_cpow@c@ (@ctype@ a, @ctype@ b)
{
    npy_intp n;
    @type@ ar = npy_creal@c@(a);
    @type@ br = npy_creal@c@(b);
    @type@ ai = npy_cimag@c@(a);
    @type@ bi = npy_cimag@c@(b);
    @ctype@ loga, r;

    if (br == 0. && bi == 0.) {
        return npy_cpack@c@(1., 0.);
    }
    if (ar == 0. && ai == 0.) {
        if (br > 0 && bi == 0) {
            return npy_cpack@c@(0., 0.);
        }
        else {
            volatile @type@ tmp = NPY_INFINITY;
            /* NB: there are four complex zeros; c0 = (+-0, +-0), so that unlike
             *     for reals, c0**p, with `p` negative is in general
             *     ill-defined.
             *
             *     c0**z with z complex is also ill-defined.
             */
            r = npy_cpack@c@(NPY_NAN, NPY_NAN);

            /* Raise invalid */
            tmp -= NPY_INFINITY;
            ar = tmp;
            return r;
        }
    }
    if (bi == 0 && (n=(npy_intp)br) == br) {
        if (n == 1) {
            /* unroll: handle inf better */
            return npy_cpack@c@(ar, ai);
        }
        else if (n == 2) {
            /* unroll: handle inf better */
            return cmul@c@(a, a);
        }
        else if (n == 3) {
            /* unroll: handle inf better */
            return cmul@c@(a, cmul@c@(a, a));
        }
        else if (n > -100 && n < 100) {
            @ctype@ p, aa;
            npy_intp mask = 1;
            if (n < 0) n = -n;
            aa = c_1@c@;
            p = npy_cpack@c@(ar, ai);
            while (1) {
                if (n & mask)
                    aa = cmul@c@(aa,p);
                mask <<= 1;
                if (n < mask || mask <= 0) break;
                p = cmul@c@(p,p);
            }
            r = npy_cpack@c@(npy_creal@c@(aa), npy_cimag@c@(aa));
            if (br < 0) r = cdiv@c@(c_1@c@, r);
            return r;
        }
    }

    loga = npy_clog@c@(a);
    ar = npy_creal@c@(loga);
    ai = npy_cimag@c@(loga);

    return npy_cexp@c@(npy_cpack@c@(ar * br - ai * bi, ar * bi + ai * br));
}
#endif

#ifndef HAVE_CCOS@C@
@ctype@ npy_ccos@c@(@ctype@ z)
{
    /* ccos(z) = ccosh(I * z) */
    return npy_ccosh@c@(npy_cpack@c@(-npy_cimag@c@(z), npy_creal@c@(z)));
}
#endif

#ifndef HAVE_CSIN@C@
@ctype@ npy_csin@c@(@ctype@ z)
{
    @type@ x, y;
    x = npy_creal@c@(z);
    y = npy_cimag@c@(z);
    return npy_cpack@c@(npy_sin@c@(x) * npy_cosh@c@(y), npy_cos@c@(x) * npy_sinh@c@(y));
}
#endif

#ifndef HAVE_CTAN@C@
@ctype@ npy_ctan@c@(@ctype@ z)
{
    /* ctan(z) = -I * ctanh(I * z) */
    z = npy_ctanh@c@(npy_cpack@c@(-npy_cimag@c@(z), npy_creal@c@(z)));
    return (npy_cpack@c@(npy_cimag@c@(z), -npy_creal@c@(z)));
}
#endif

#ifndef HAVE_CCOSH@C@
/*
 * Taken from the msun library in FreeBSD, rev 226599.
 *
 * Hyperbolic cosine of a complex argument z = x + i y.
 *
 * cosh(z) = cosh(x+iy)
 *         = cosh(x) cos(y) + i sinh(x) sin(y).
 *
 * Exceptional values are noted in the comments within the source code.
 * These values and the return value were taken from n1124.pdf.
 *
 * CCOSH_BIG is chosen such that
 * spacing(0.5 * exp(CCOSH_BIG)) > 0.5*exp(-CCOSH_BIG)
 * although the exact value assigned to CCOSH_BIG is not so important
 */
#if @precision@ == 1
#define CCOSH_BIG 9.0f
#define CCOSH_HUGE 1.70141183e+38f
#endif
#if @precision@ == 2
#define CCOSH_BIG 22.0
#define CCOSH_HUGE 8.9884656743115795e+307
#endif
#if @precision@ >= 3
#define CCOSH_BIG 24.0L
#define CCOSH_HUGE 5.94865747678615882543e+4931L
#endif

@ctype@ npy_ccosh@c@(@ctype@ z)
{
    @type@  x, y, h, absx;
    npy_int xfinite, yfinite;

    x = npy_creal@c@(z);
    y = npy_cimag@c@(z);

    xfinite = npy_isfinite(x);
    yfinite = npy_isfinite(y);

    /* Handle the nearly-non-exceptional cases where x and y are finite. */
    if (xfinite && yfinite) {
        if (y == 0)
            return npy_cpack@c@(npy_cosh@c@(x), x * y);
        absx = npy_fabs@c@(x);
        if (absx < CCOSH_BIG)   /* small x: normal case */
            return npy_cpack@c@(npy_cosh@c@(x) * npy_cos@c@(y), npy_sinh@c@(x) * npy_sin@c@(y));

        /* |x| >= 22, so cosh(x) ~= exp(|x|) */
        if (absx < SCALED_CEXP_LOWER@C@) {
            /* x < 710: exp(|x|) won't overflow */
            h = npy_exp@c@(absx) * 0.5;
            return npy_cpack@c@(h * npy_cos@c@(y), npy_copysign@c@(h, x) * npy_sin@c@(y));
        } else if (absx < SCALED_CEXP_UPPER@C@) {
            /* x < 1455: scale to avoid overflow */
            z = _npy_scaled_cexp@c@(absx, y, -1);
            return npy_cpack@c@(npy_creal@c@(z), npy_cimag@c@(z) * npy_copysign@c@(1, x));
        } else {
            /* x >= 1455: the result always overflows */
            h = CCOSH_HUGE * x;
            return npy_cpack@c@(h * h * npy_cos@c@(y), h * npy_sin@c@(y));
        }
    }

    /*
     * cosh(+-0 +- I Inf) = dNaN + I sign(d(+-0, dNaN))0.
     * The sign of 0 in the result is unspecified.  Choice = normally
     * the same as dNaN.  Raise the invalid floating-point exception.
     *
     * cosh(+-0 +- I NaN) = d(NaN) + I sign(d(+-0, NaN))0.
     * The sign of 0 in the result is unspecified.  Choice = normally
     * the same as d(NaN).
     */
    if (x == 0 && !yfinite)
        return npy_cpack@c@(y - y, npy_copysign@c@(0, x * (y - y)));

    /*
     * cosh(+-Inf +- I 0) = +Inf + I (+-)(+-)0.
     *
     * cosh(NaN +- I 0)   = d(NaN) + I sign(d(NaN, +-0))0.
     * The sign of 0 in the result is unspecified.
     */
    if (y == 0 && !xfinite)
        return npy_cpack@c@(x * x, npy_copysign@c@(0, x) * y);

    /*
     * cosh(x +- I Inf) = dNaN + I dNaN.
     * Raise the invalid floating-point exception for finite nonzero x.
     *
     * cosh(x + I NaN) = d(NaN) + I d(NaN).
     * Optionally raises the invalid floating-point exception for finite
     * nonzero x.  Choice = don't raise (except for signaling NaNs).
     */
    if (xfinite && !yfinite)
        return npy_cpack@c@(y - y, x * (y - y));

    /*
     * cosh(+-Inf + I NaN)  = +Inf + I d(NaN).
     *
     * cosh(+-Inf +- I Inf) = +Inf + I dNaN.
     * The sign of Inf in the result is unspecified.  Choice = always +.
     * Raise the invalid floating-point exception.
     *
     * cosh(+-Inf + I y)   = +Inf cos(y) +- I Inf sin(y)
     */
    if (npy_isinf(x)) {
        if (!yfinite)
            return npy_cpack@c@(x * x, x * (y - y));
        return npy_cpack@c@((x * x) * npy_cos@c@(y), x * npy_sin@c@(y));
    }

    /*
     * cosh(NaN + I NaN)  = d(NaN) + I d(NaN).
     *
     * cosh(NaN +- I Inf) = d(NaN) + I d(NaN).
     * Optionally raises the invalid floating-point exception.
     * Choice = raise.
     *
     * cosh(NaN + I y)    = d(NaN) + I d(NaN).
     * Optionally raises the invalid floating-point exception for finite
     * nonzero y.  Choice = don't raise (except for signaling NaNs).
     */
    return npy_cpack@c@((x * x) * (y - y), (x + x) * (y - y));
}
#undef CCOSH_BIG
#undef CCOSH_HUGE
#endif

#ifndef HAVE_CSINH@C@
@ctype@ npy_csinh@c@(@ctype@ z)
{
    @type@ x, y;
    x = npy_creal@c@(z);
    y = npy_cimag@c@(z);
    return npy_cpack@c@(npy_cos@c@(y)*npy_sinh@c@(x), npy_sin@c@(y)*npy_cosh@c@(x));
}
#endif

#ifndef HAVE_CTANH@C@
/*
 * Taken from the msun library in FreeBSD, rev 226600.
 *
 * Hyperbolic tangent of a complex argument z = x + i y.
 *
 * The algorithm is from:
 *
 *   W. Kahan.  Branch Cuts for Complex Elementary Functions or Much
 *   Ado About Nothing's Sign Bit.  In The State of the Art in
 *   Numerical Analysis, pp. 165 ff.  Iserles and Powell, eds., 1987.
 *
 * Method:
 *
 *   Let t    = tan(x)
 *       beta = 1/cos^2(y)
 *       s    = sinh(x)
 *       rho  = cosh(x)
 *
 *   We have:
 *
 *   tanh(z) = sinh(z) / cosh(z)
 *
 *             sinh(x) cos(y) + i cosh(x) sin(y)
 *           = ---------------------------------
 *             cosh(x) cos(y) + i sinh(x) sin(y)
 *
 *             cosh(x) sinh(x) / cos^2(y) + i tan(y)
 *           = -------------------------------------
 *                    1 + sinh^2(x) / cos^2(y)
 *
 *             beta rho s + i t
 *           = ----------------
 *               1 + beta s^2
 *
 * Modifications:
 *
 *   I omitted the original algorithm's handling of overflow in tan(x) after
 *   verifying with nearpi.c that this can't happen in IEEE single or double
 *   precision.  I also handle large x differently.
 */

#define TANH_HUGE 22.0
#define TANHF_HUGE 11.0F
#define TANHL_HUGE 42.0L

@ctype@ npy_ctanh@c@(@ctype@ z)
{
    @type@ x, y;
    @type@ t, beta, s, rho, denom;

    x = npy_creal@c@(z);
    y = npy_cimag@c@(z);

    /*
     * ctanh(NaN + i 0) = NaN + i 0
     *
     * ctanh(NaN + i y) = NaN + i NaN        for y != 0
     *
     * The imaginary part has the sign of x*sin(2*y), but there's no
     * special effort to get this right.
     *
     * ctanh(+-Inf +- i Inf) = +-1 +- 0
     *
     * ctanh(+-Inf + i y) = +-1 + 0 sin(2y)        for y finite
     *
     * The imaginary part of the sign is unspecified.  This special
     * case is only needed to avoid a spurious invalid exception when
     * y is infinite.
     */
        if (!npy_isfinite(x)) {
            if (npy_isnan(x))
                return npy_cpack@c@(x, (y == 0 ? y : x * y));
            return npy_cpack@c@(npy_copysign@c@(1,x),
                npy_copysign@c@(0,
                npy_isinf(y) ? y : npy_sin@c@(y) * npy_cos@c@(y)));
        }

    /*
     * ctanh(x + i NAN) = NaN + i NaN
     * ctanh(x +- i Inf) = NaN + i NaN
     */
    if (!npy_isfinite(y))
        return (npy_cpack@c@(y - y, y - y));

    /*
     * ctanh(+-huge + i +-y) ~= +-1 +- i 2sin(2y)/exp(2x), using the
     * approximation sinh^2(huge) ~= exp(2*huge) / 4.
     * We use a modified formula to avoid spurious overflow.
     */
    if (npy_fabs@c@(x) >= TANH@C@_HUGE) {
        @type@ exp_mx = npy_exp@c@(-npy_fabs@c@(x));
        return (npy_cpack@c@(npy_copysign@c@(1, x),
            4 * npy_sin@c@(y) * npy_cos@c@(y) * exp_mx * exp_mx));
    }

    /* Kahan's algorithm */
    t = npy_tan@c@(y);
    beta = 1.0 + t * t;    /* = 1 / cos^2(y) */
    s = npy_sinh@c@(x);
    rho = npy_sqrt@c@(1 + s * s);    /* = cosh(x) */
    denom = 1 + beta * s * s;
    return (npy_cpack@c@((beta * rho * s) / denom, t / denom));
}
#undef TANH_HUGE
#undef TANHF_HUGE
#undef TANHL_HUGE
#endif

#ifndef HAVE_CACOS@C@
@ctype@ npy_cacos@c@(@ctype@ z)
{
    @ctype@ r;
    r = cmul@c@(z,z);
    r = csub@c@(c_1@c@, r);
    r = npy_csqrt@c@(r);
    r = cmuli@c@(r);
    r = cadd@c@(z, r);
    r = npy_clog@c@(r);
    r = cmuli@c@(r);
    r = cneg@c@(r);
    return r;
}
#endif

#ifndef HAVE_CASIN@C@
@ctype@ npy_casin@c@(@ctype@ z)
{
    @type@ x, y;
    x = npy_creal@c@(z);
    y = npy_cimag@c@(z);

    if (npy_fabs(x) > 1e-3 || npy_fabs(y) > 1e-3) {
        /* casin(z) = -i * log( i*z + sqrt(1-z**2)) */
        @ctype@ m1, iz, r;
        m1 = npy_csqrt@c@(csub@c@(c_1@c@, cmul@c@(z,z)));
        iz = cmuli@c@(z);
        r = npy_clog@c@(cadd@c@(iz, m1));
        r = cmuli@c@(r);
        return cneg@c@(r);
    }
    else {
        /*
         * Small arguments: series expansion, to avoid loss of precision
         * asin(x) = x [1 + (1/6) x^2 [1 + (9/20) x^2 [1 + ...]]]
         *
         * |x| < 1e-3 => |rel. error| < 1e-18 (f), 1e-24, 1e-36 (l)
         */
        @ctype@ z2, r;
        z2 = cmul@c@(z, z);
        r = c_1@c@;
#if @precision@ >= 3
        SERIES_HORNER_TERM@C@(r, z2, 81.0@C@/110);
        SERIES_HORNER_TERM@C@(r, z2, 49.0@C@/72);
#endif
#if @precision@ >= 2
        SERIES_HORNER_TERM@C@(r, z2, 25.0@C@/42);
#endif
        SERIES_HORNER_TERM@C@(r, z2, 9.0@C@/20);
        SERIES_HORNER_TERM@C@(r, z2, 1.0@C@/6);
        return cmul@c@(r, z);
    }
}
#endif

#ifndef HAVE_CATAN@C@
@ctype@ npy_catan@c@(@ctype@ z)
{
    @type@ x, y;
    x = npy_creal@c@(z);
    y = npy_cimag@c@(z);

    if (npy_fabs(x) > 1e-3 || npy_fabs(y) > 1e-3) {
        /* catan(z) = 0.5*i * log((i+z)/(i-z)) */
        @ctype@ ip, im;
        ip = cadd@c@(c_i@c@, z);
        im = csub@c@(c_i@c@, z);
        return cmul@c@(c_ihalf@c@, npy_clog@c@(cdiv@c@(ip, im)));
    }
    else {
        /*
         * Small arguments: series expansion, to avoid loss of precision
         * atan(x) = x [1 - (1/3) x^2 [1 - (3/5) x^2 [1 - ...]]]
         *
         * |x| < 1e-3 => |rel. error| < 1e-18 (f), 1e-24, 1e-36 (l)
         */
        @ctype@ z2, r;
        z2 = cmul@c@(z, z);
        r = c_1@c@;
#if @precision@ >= 3
        SERIES_HORNER_TERM@C@(r, z2, -9.0@C@/11);
        SERIES_HORNER_TERM@C@(r, z2, -7.0@C@/9);
#endif
#if @precision@ >= 2
        SERIES_HORNER_TERM@C@(r, z2, -5.0@C@/7);
#endif
        SERIES_HORNER_TERM@C@(r, z2, -3.0@C@/5);
        SERIES_HORNER_TERM@C@(r, z2, -1.0@C@/3);
        return cmul@c@(r, z);
     }
}
#endif

#ifndef HAVE_CACOSH@C@
@ctype@ npy_cacosh@c@(@ctype@ z)
{
    /* cacosh(z) = log( z + sqrt(z+1)*sqrt(z-1)) */
    @ctype@ p1, m1;
    p1 = npy_csqrt@c@(cadd@c@(z, c_1@c@));
    m1 = npy_csqrt@c@(csub@c@(z, c_1@c@));
    return npy_clog@c@(cadd@c@(z, cmul@c@(p1,m1)));
}
#endif

#ifndef HAVE_CASINH@C@
@ctype@ npy_casinh@c@(@ctype@ z)
{
    @type@ x, y;

    x = npy_creal@c@(z);
    y = npy_cimag@c@(z);

    if (npy_fabs(x) > 1e-3 || npy_fabs(y) > 1e-3) {
        /* casinh(z) = log( z + sqrt(1 + z**2)) */
        @ctype@ p1;
        p1 = npy_csqrt@c@(cadd@c@(c_1@c@, cmul@c@(z, z)));
        return npy_clog@c@(cadd@c@(p1, z));
    }
    else {
        /*
         * Small arguments: series expansion, to avoid loss of precision
         * asinh(x) = x [1 - (1/6) x^2 [1 - (9/20) x^2 [1 - ...]]]
         *
         * |x| < 1e-3 => |rel. error| < 1e-18 (f), 1e-24, 1e-36 (l)
         */
        @ctype@ z2, r;
        z2 = cmul@c@(z, z);
        r = c_1@c@;
#if @precision@ >= 3
        SERIES_HORNER_TERM@C@(r, z2, -81.0@C@/110);
        SERIES_HORNER_TERM@C@(r, z2, -49.0@C@/72);
#endif
#if @precision@ >= 2
        SERIES_HORNER_TERM@C@(r, z2, -25.0@C@/42);
#endif
        SERIES_HORNER_TERM@C@(r, z2, -9.0@C@/20);
        SERIES_HORNER_TERM@C@(r, z2, -1.0@C@/6);
        return cmul@c@(z, r);
    }
}
#endif

#ifndef HAVE_CATANH@C@
@ctype@ npy_catanh@c@(@ctype@ z)
{
    @type@ x, y;

    x = npy_creal@c@(z);
    y = npy_cimag@c@(z);

    if (npy_fabs(x) > 1e-3 || npy_fabs(y) > 1e-3) {
        /* catanh(z) = 0.5 * log((1+z)/(1-z)) */
        @ctype@ p1, m1;
        p1 = cadd@c@(c_1@c@, z);
        m1 = csub@c@(c_1@c@, z);
        return cmul@c@(c_half@c@, npy_clog@c@(cdiv@c@(p1, m1)));
    }
    else {
        /*
         * Small arguments: series expansion, to avoid loss of precision
         * atan(x) = x [1 + (1/3) x^2 [1 + (3/5) x^2 [1 + ...]]]
         *
         * |x| < 1e-3 => |rel. error| < 1e-18 (f), 1e-24, 1e-36 (l)
         */
        @ctype@ z2, r;
        z2 = cmul@c@(z, z);
        r = c_1@c@;
#if @precision@ >= 3
        SERIES_HORNER_TERM@C@(r, z2, 9.0@C@/11);
        SERIES_HORNER_TERM@C@(r, z2, 7.0@C@/9);
#endif
#if @precision@ >= 2
        SERIES_HORNER_TERM@C@(r, z2, 5.0@C@/7);
#endif
        SERIES_HORNER_TERM@C@(r, z2, 3.0@C@/5);
        SERIES_HORNER_TERM@C@(r, z2, 1.0@C@/3);
        return cmul@c@(z, r);
     }
}
#endif
/**end repeat**/

/*==========================================================
 * Decorate all the functions which are available natively
 *=========================================================*/

/**begin repeat
 * #type = npy_float, npy_double, npy_longdouble#
 * #ctype = npy_cfloat, npy_cdouble, npy_clongdouble#
 * #c = f, , l#
 * #C = F, , L#
 */

/**begin repeat1
 * #kind = cabs,carg#
 * #KIND = CABS,CARG#
 */
#ifdef HAVE_@KIND@@C@
@type@ npy_@kind@@c@(@ctype@ z)
{
    __@ctype@_to_c99_cast z1 = {z};
    return @kind@@c@(z1.c99_z);
}
#endif
/**end repeat1**/

/**begin repeat1
 * #kind = cexp,clog,csqrt,ccos,csin,ctan,ccosh,csinh,ctanh,cacos,casin,catan,cacosh,casinh,catanh#
 * #KIND = CEXP,CLOG,CSQRT,CCOS,CSIN,CTAN,CCOSH,CSINH,CTANH,CACOS,CASIN,CATAN,CACOSH,CASINH,CATANH#
 */
#ifdef HAVE_@KIND@@C@
@ctype@ npy_@kind@@c@(@ctype@ z)
{
    __@ctype@_to_c99_cast z1 = {z};
    __@ctype@_to_c99_cast ret;
    ret.c99_z = @kind@@c@(z1.c99_z);
    return ret.npy_z;
}
#endif
/**end repeat1**/

/**begin repeat1
 * #kind = cpow#
 * #KIND = CPOW#
 */
#ifdef HAVE_@KIND@@C@
@ctype@ npy_@kind@@c@(@ctype@ x, @ctype@ y)
{
    __@ctype@_to_c99_cast xcast = {x};
    __@ctype@_to_c99_cast ycast = {y};
    __@ctype@_to_c99_cast ret;
    ret.c99_z = @kind@@c@(xcast.c99_z, ycast.c99_z);
    return ret.npy_z;
}
#endif
/**end repeat1**/

/**end repeat**/
